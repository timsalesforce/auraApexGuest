(function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs$1 (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var js_cookie = {exports: {}};

	/*!
	 * JavaScript Cookie v2.2.1
	 * https://github.com/js-cookie/js-cookie
	 *
	 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
	 * Released under the MIT license
	 */

	(function (module, exports) {
	(function (factory) {
			var registeredInModuleLoader;
			{
				module.exports = factory();
				registeredInModuleLoader = true;
			}
			if (!registeredInModuleLoader) {
				var OldCookies = window.Cookies;
				var api = window.Cookies = factory();
				api.noConflict = function () {
					window.Cookies = OldCookies;
					return api;
				};
			}
		}(function () {
			function extend () {
				var i = 0;
				var result = {};
				for (; i < arguments.length; i++) {
					var attributes = arguments[ i ];
					for (var key in attributes) {
						result[key] = attributes[key];
					}
				}
				return result;
			}

			function decode (s) {
				return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
			}

			function init (converter) {
				function api() {}

				function set (key, value, attributes) {
					if (typeof document === 'undefined') {
						return;
					}

					attributes = extend({
						path: '/'
					}, api.defaults, attributes);

					if (typeof attributes.expires === 'number') {
						attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
					}

					// We're using "expires" because "max-age" is not supported by IE
					attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

					try {
						var result = JSON.stringify(value);
						if (/^[\{\[]/.test(result)) {
							value = result;
						}
					} catch (e) {}

					value = converter.write ?
						converter.write(value, key) :
						encodeURIComponent(String(value))
							.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

					key = encodeURIComponent(String(key))
						.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
						.replace(/[\(\)]/g, escape);

					var stringifiedAttributes = '';
					for (var attributeName in attributes) {
						if (!attributes[attributeName]) {
							continue;
						}
						stringifiedAttributes += '; ' + attributeName;
						if (attributes[attributeName] === true) {
							continue;
						}

						// Considers RFC 6265 section 5.2:
						// ...
						// 3.  If the remaining unparsed-attributes contains a %x3B (";")
						//     character:
						// Consume the characters of the unparsed-attributes up to,
						// not including, the first %x3B (";") character.
						// ...
						stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
					}

					return (document.cookie = key + '=' + value + stringifiedAttributes);
				}

				function get (key, json) {
					if (typeof document === 'undefined') {
						return;
					}

					var jar = {};
					// To prevent the for loop in the first place assign an empty array
					// in case there are no cookies at all.
					var cookies = document.cookie ? document.cookie.split('; ') : [];
					var i = 0;

					for (; i < cookies.length; i++) {
						var parts = cookies[i].split('=');
						var cookie = parts.slice(1).join('=');

						if (!json && cookie.charAt(0) === '"') {
							cookie = cookie.slice(1, -1);
						}

						try {
							var name = decode(parts[0]);
							cookie = (converter.read || converter)(cookie, name) ||
								decode(cookie);

							if (json) {
								try {
									cookie = JSON.parse(cookie);
								} catch (e) {}
							}

							jar[name] = cookie;

							if (key === name) {
								break;
							}
						} catch (e) {}
					}

					return key ? jar[key] : jar;
				}

				api.set = set;
				api.get = function (key) {
					return get(key, false /* read as raw */);
				};
				api.getJSON = function (key) {
					return get(key, true /* read as json */);
				};
				api.remove = function (key, attributes) {
					set(key, '', extend(attributes, {
						expires: -1
					}));
				};

				api.defaults = {};

				api.withConverter = init;

				return api;
			}

			return init(function () {});
		})); 
	} (js_cookie));

	var js_cookieExports = js_cookie.exports;
	var jsCookie = /*@__PURE__*/getDefaultExportFromCjs$1(js_cookieExports);

	/* MIT https://github.com/kenwheeler/cash */
	const doc = document, win = window, docEle = doc.documentElement, createElement = doc.createElement.bind(doc), div = createElement('div'), table = createElement('table'), tbody = createElement('tbody'), tr = createElement('tr'), { isArray, prototype: ArrayProtoType } = Array, { filter, indexOf, map, push, slice, some, splice } = ArrayProtoType;
	const idRe = /^#[\w-]*$/, classRe = /^\.[\w-]*$/, htmlRe = /<.+>/, tagRe = /^\w+$/;
	// @require ./variables.ts
	function find(selector, context = doc) {
	    return !isDocument(context) && !isElement(context)
	        ? []
	        : classRe.test(selector)
	            ? context.getElementsByClassName(selector.slice(1))
	            : tagRe.test(selector)
	                ? context.getElementsByTagName(selector)
	                : context.querySelectorAll(selector);
	}
	// @require ./find.ts
	// @require ./variables.ts
	class Cash {
	    constructor(selector, context = doc) {
	        if (!selector)
	            return;
	        if (isCash(selector))
	            return selector;
	        let eles = selector;
	        if (isString(selector)) {
	            const ctx = isCash(context) ? context[0] : context;
	            eles = idRe.test(selector)
	                ? ctx.getElementById(selector.slice(1))
	                : htmlRe.test(selector)
	                    ? parseHTML(selector)
	                    : find(selector, ctx);
	            if (!eles)
	                return;
	        }
	        else if (isFunction(selector)) {
	            return this.ready(selector); //FIXME: `fn.ready` is not included in `core`, but it's actually a core functionality
	        }
	        if (eles.nodeType || eles === win)
	            eles = [eles];
	        this.length = eles.length;
	        for (let i = 0, l = this.length; i < l; i++) {
	            this[i] = eles[i];
	        }
	    }
	    init(selector, context) {
	        return new Cash(selector, context);
	    }
	}
	const fn = Cash.prototype, cash = fn.init;
	cash.fn = cash.prototype = fn; // Ensuring that `cash () instanceof cash`
	fn.length = 0;
	fn.splice = splice; // Ensuring a cash collection gets printed as array-like in Chrome's devtools
	if (typeof Symbol === 'function') { // Ensuring a cash collection is iterable
	    fn[Symbol['iterator']] = ArrayProtoType[Symbol['iterator']];
	}
	fn.map = function (callback) {
	    return cash(map.call(this, (ele, i) => callback.call(ele, i, ele)));
	};
	fn.slice = function (start, end) {
	    return cash(slice.call(this, start, end));
	};
	const dashAlphaRe = /-([a-z])/g;
	function camelCase$2(str) {
	    return str.replace(dashAlphaRe, (match, letter) => letter.toUpperCase());
	}
	cash.camelCase = camelCase$2;
	function each(arr, callback, reverse) {
	    if (reverse) {
	        let i = arr.length;
	        while (i--) {
	            if (callback.call(arr[i], i, arr[i]) === false)
	                return arr;
	        }
	    }
	    else {
	        for (let i = 0, l = arr.length; i < l; i++) {
	            if (callback.call(arr[i], i, arr[i]) === false)
	                return arr;
	        }
	    }
	    return arr;
	}
	cash.each = each;
	fn.each = function (callback) {
	    return each(this, callback);
	};
	fn.removeProp = function (prop) {
	    return this.each((i, ele) => { delete ele[prop]; });
	};
	cash.extend = function (target, ...objs) {
	    const length = arguments.length;
	    for (let i = (length < 2 ? 0 : 1); i < length; i++) {
	        for (const key in arguments[i]) {
	            target[key] = arguments[i][key];
	        }
	    }
	    return target;
	};
	fn.extend = function (plugins) {
	    return cash.extend(fn, plugins);
	};
	cash.guid = 1;
	function matches(ele, selector) {
	    const matches = ele && (ele['matches'] || ele['webkitMatchesSelector'] || ele['msMatchesSelector']);
	    return !!matches && matches.call(ele, selector);
	}
	cash.matches = matches;
	function isCash(x) {
	    return x instanceof Cash;
	}
	function isWindow(x) {
	    return !!x && x === x.window;
	}
	function isDocument(x) {
	    return !!x && x.nodeType === 9;
	}
	function isElement(x) {
	    return !!x && x.nodeType === 1;
	}
	function isFunction(x) {
	    return typeof x === 'function';
	}
	function isString(x) {
	    return typeof x === 'string';
	}
	function isUndefined(x) {
	    return x === undefined;
	}
	function isNull(x) {
	    return x === null;
	}
	function isNumeric(x) {
	    return !isNaN(parseFloat(x)) && isFinite(x);
	}
	cash.isWindow = isWindow;
	cash.isFunction = isFunction;
	cash.isString = isString;
	cash.isNumeric = isNumeric;
	cash.isArray = isArray;
	fn.prop = function (prop, value) {
	    if (!prop)
	        return;
	    if (isString(prop)) {
	        if (arguments.length < 2)
	            return this[0] && this[0][prop];
	        return this.each((i, ele) => { ele[prop] = value; });
	    }
	    for (const key in prop) {
	        this.prop(key, prop[key]);
	    }
	    return this;
	};
	fn.get = function (index) {
	    if (isUndefined(index))
	        return slice.call(this);
	    return this[index < 0 ? index + this.length : index];
	};
	fn.eq = function (index) {
	    return cash(this.get(index));
	};
	fn.first = function () {
	    return this.eq(0);
	};
	fn.last = function () {
	    return this.eq(-1);
	};
	// @require ./matches.ts
	// @require ./type_checking.ts
	function getCompareFunction(comparator) {
	    return isString(comparator)
	        ? (i, ele) => matches(ele, comparator)
	        : isFunction(comparator)
	            ? comparator
	            : isCash(comparator)
	                ? (i, ele) => comparator.is(ele)
	                : !comparator
	                    ? () => false
	                    : (i, ele) => ele === comparator;
	}
	fn.filter = function (comparator) {
	    const compare = getCompareFunction(comparator);
	    return cash(filter.call(this, (ele, i) => compare.call(ele, i, ele)));
	};
	// @require collection/filter.ts
	function filtered(collection, comparator) {
	    return !comparator ? collection : collection.filter(comparator);
	}
	// @require ./type_checking.ts
	const splitValuesRe = /\S+/g;
	function getSplitValues(str) {
	    return isString(str) ? str.match(splitValuesRe) || [] : [];
	}
	fn.hasClass = function (cls) {
	    return !!cls && some.call(this, (ele) => ele.classList.contains(cls));
	};
	fn.removeAttr = function (attr) {
	    const attrs = getSplitValues(attr);
	    return this.each((i, ele) => {
	        each(attrs, (i, a) => {
	            ele.removeAttribute(a);
	        });
	    });
	};
	function attr(attr, value) {
	    if (!attr)
	        return;
	    if (isString(attr)) {
	        if (arguments.length < 2) {
	            if (!this[0])
	                return;
	            const value = this[0].getAttribute(attr);
	            return isNull(value) ? undefined : value;
	        }
	        if (isUndefined(value))
	            return this;
	        if (isNull(value))
	            return this.removeAttr(attr);
	        return this.each((i, ele) => { ele.setAttribute(attr, value); });
	    }
	    for (const key in attr) {
	        this.attr(key, attr[key]);
	    }
	    return this;
	}
	fn.attr = attr;
	fn.toggleClass = function (cls, force) {
	    const classes = getSplitValues(cls), isForce = !isUndefined(force);
	    return this.each((i, ele) => {
	        each(classes, (i, c) => {
	            if (isForce) {
	                force ? ele.classList.add(c) : ele.classList.remove(c);
	            }
	            else {
	                ele.classList.toggle(c);
	            }
	        });
	    });
	};
	fn.addClass = function (cls) {
	    return this.toggleClass(cls, true);
	};
	fn.removeClass = function (cls) {
	    if (arguments.length)
	        return this.toggleClass(cls, false);
	    return this.attr('class', '');
	};
	function pluck(arr, prop, deep) {
	    const plucked = [], isCallback = isFunction(prop);
	    for (let i = 0, l = arr.length; i < l; i++) {
	        if (isCallback) {
	            const val = prop(arr[i]);
	            if (val.length)
	                push.apply(plucked, val);
	        }
	        else {
	            let val = arr[i][prop];
	            while (val != null) {
	                plucked.push(val);
	                val = deep ? val[prop] : null;
	            }
	        }
	    }
	    return plucked;
	}
	function unique(arr) {
	    return arr.length > 1 ? filter.call(arr, (item, index, self) => indexOf.call(self, item) === index) : arr;
	}
	cash.unique = unique;
	fn.add = function (selector, context) {
	    return cash(unique(this.get().concat(cash(selector, context).get())));
	};
	// @require core/type_checking.ts
	// @require core/variables.ts
	function computeStyle(ele, prop, isVariable) {
	    if (!isElement(ele) || !prop)
	        return;
	    const style = win.getComputedStyle(ele, null);
	    return prop ? (isVariable ? style.getPropertyValue(prop) || undefined : style[prop]) : style;
	}
	// @require ./compute_style.ts
	function computeStyleInt(ele, prop) {
	    return parseInt(computeStyle(ele, prop), 10) || 0;
	}
	const cssVariableRe = /^--/;
	// @require ./variables.ts
	function isCSSVariable(prop) {
	    return cssVariableRe.test(prop);
	}
	const prefixedProps = {}, { style } = div, vendorsPrefixes = ['webkit', 'moz', 'ms'];
	function getPrefixedProp(prop, isVariable = isCSSVariable(prop)) {
	    if (isVariable)
	        return prop;
	    if (!prefixedProps[prop]) {
	        const propCC = camelCase$2(prop), propUC = `${propCC[0].toUpperCase()}${propCC.slice(1)}`, props = (`${propCC} ${vendorsPrefixes.join(`${propUC} `)}${propUC}`).split(' ');
	        each(props, (i, p) => {
	            if (p in style) {
	                prefixedProps[prop] = p;
	                return false;
	            }
	        });
	    }
	    return prefixedProps[prop];
	}
	cash.prefixedProp = getPrefixedProp;
	// @require core/type_checking.ts
	// @require ./is_css_variable.ts
	const numericProps = {
	    animationIterationCount: true,
	    columnCount: true,
	    flexGrow: true,
	    flexShrink: true,
	    fontWeight: true,
	    lineHeight: true,
	    opacity: true,
	    order: true,
	    orphans: true,
	    widows: true,
	    zIndex: true
	};
	function getSuffixedValue(prop, value, isVariable = isCSSVariable(prop)) {
	    return !isVariable && !numericProps[prop] && isNumeric(value) ? `${value}px` : value;
	}
	function css(prop, value) {
	    if (isString(prop)) {
	        const isVariable = isCSSVariable(prop);
	        prop = getPrefixedProp(prop, isVariable);
	        if (arguments.length < 2)
	            return this[0] && computeStyle(this[0], prop, isVariable);
	        if (!prop)
	            return this;
	        value = getSuffixedValue(prop, value, isVariable);
	        return this.each((i, ele) => {
	            if (!isElement(ele))
	                return;
	            if (isVariable) {
	                ele.style.setProperty(prop, value);
	            }
	            else {
	                ele.style[prop] = value;
	            }
	        });
	    }
	    for (const key in prop) {
	        this.css(key, prop[key]);
	    }
	    return this;
	}
	fn.css = css;
	// @optional ./css.ts
	// @require core/camel_case.ts
	function getData(ele, key) {
	    const value = ele.dataset[key] || ele.dataset[camelCase$2(key)];
	    try {
	        return JSON.parse(value);
	    }
	    catch (_a) { }
	    return value;
	}
	// @require core/camel_case.ts
	function setData(ele, key, value) {
	    try {
	        value = JSON.stringify(value);
	    }
	    catch (_a) { }
	    ele.dataset[camelCase$2(key)] = value;
	}
	function data(name, value) {
	    if (!name) {
	        if (!this[0])
	            return;
	        const datas = {};
	        for (const key in this[0].dataset) {
	            datas[key] = getData(this[0], key);
	        }
	        return datas;
	    }
	    if (isString(name)) {
	        if (arguments.length < 2)
	            return this[0] && getData(this[0], name);
	        return this.each((i, ele) => { setData(ele, name, value); });
	    }
	    for (const key in name) {
	        this.data(key, name[key]);
	    }
	    return this;
	}
	fn.data = data;
	// @optional ./data.ts
	// @require css/helpers/compute_style_int.ts
	function getExtraSpace(ele, xAxis) {
	    return computeStyleInt(ele, `border${xAxis ? 'Left' : 'Top'}Width`) + computeStyleInt(ele, `padding${xAxis ? 'Left' : 'Top'}`) + computeStyleInt(ele, `padding${xAxis ? 'Right' : 'Bottom'}`) + computeStyleInt(ele, `border${xAxis ? 'Right' : 'Bottom'}Width`);
	}
	each([true, false], (i, outer) => {
	    each(['Width', 'Height'], (i, prop) => {
	        const name = `${outer ? 'outer' : 'inner'}${prop}`;
	        fn[name] = function (includeMargins) {
	            if (!this[0])
	                return;
	            if (isWindow(this[0]))
	                return win[name];
	            return this[0][`${outer ? 'offset' : 'client'}${prop}`] + (includeMargins && outer ? computeStyleInt(this[0], `margin${i ? 'Top' : 'Left'}`) + computeStyleInt(this[0], `margin${i ? 'Bottom' : 'Right'}`) : 0);
	        };
	    });
	});
	each(['width', 'height'], (index, prop) => {
	    fn[prop] = function (value) {
	        if (!this[0])
	            return isUndefined(value) ? undefined : this;
	        if (!arguments.length) {
	            if (isWindow(this[0]))
	                return this[0][camelCase$2(`outer-${prop}`)];
	            return this[0].getBoundingClientRect()[prop] - getExtraSpace(this[0], !index);
	        }
	        const valueNumber = parseInt(value, 10);
	        return this.each((i, ele) => {
	            if (!isElement(ele))
	                return;
	            const boxSizing = computeStyle(ele, 'boxSizing');
	            ele.style[prop] = getSuffixedValue(prop, valueNumber + (boxSizing === 'border-box' ? getExtraSpace(ele, !index) : 0));
	        });
	    };
	});
	// @optional ./inner_outer.ts
	// @optional ./normal.ts
	// @require css/helpers/compute_style.ts
	const defaultDisplay = {};
	function getDefaultDisplay(tagName) {
	    if (defaultDisplay[tagName])
	        return defaultDisplay[tagName];
	    const ele = createElement(tagName);
	    doc.body.insertBefore(ele, null);
	    const display = computeStyle(ele, 'display');
	    doc.body.removeChild(ele);
	    return defaultDisplay[tagName] = display !== 'none' ? display : 'block';
	}
	// @require css/helpers/compute_style.ts
	function isHidden(ele) {
	    return computeStyle(ele, 'display') === 'none';
	}
	const displayProperty = '___cd';
	fn.toggle = function (force) {
	    return this.each((i, ele) => {
	        const show = isUndefined(force) ? isHidden(ele) : force;
	        if (show) {
	            ele.style.display = ele[displayProperty] || '';
	            if (isHidden(ele)) {
	                ele.style.display = getDefaultDisplay(ele.tagName);
	            }
	        }
	        else {
	            ele[displayProperty] = computeStyle(ele, 'display');
	            ele.style.display = 'none';
	        }
	    });
	};
	fn.hide = function () {
	    return this.toggle(false);
	};
	fn.show = function () {
	    return this.toggle(true);
	};
	// @optional ./hide.ts
	// @optional ./show.ts
	// @optional ./toggle.ts
	function hasNamespaces(ns1, ns2) {
	    return !ns2 || !some.call(ns2, (ns) => ns1.indexOf(ns) < 0);
	}
	const eventsNamespace = '___ce', eventsNamespacesSeparator = '.', eventsFocus = { focus: 'focusin', blur: 'focusout' }, eventsHover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }, eventsMouseRe = /^(mouse|pointer|contextmenu|drag|drop|click|dblclick)/i;
	// @require ./variables.ts
	function getEventNameBubbling(name) {
	    return eventsHover[name] || eventsFocus[name] || name;
	}
	// @require ./variables.ts
	function getEventsCache(ele) {
	    return ele[eventsNamespace] = (ele[eventsNamespace] || {});
	}
	// @require core/guid.ts
	// @require events/helpers/get_events_cache.ts
	function addEvent(ele, name, namespaces, selector, callback) {
	    callback.guid = callback.guid || cash.guid++;
	    const eventCache = getEventsCache(ele);
	    eventCache[name] = (eventCache[name] || []);
	    eventCache[name].push([namespaces, selector, callback]);
	    ele.addEventListener(name, callback);
	}
	// @require ./variables.ts
	function parseEventName(eventName) {
	    const parts = eventName.split(eventsNamespacesSeparator);
	    return [parts[0], parts.slice(1).sort()]; // [name, namespace[]]
	}
	// @require ./get_events_cache.ts
	// @require ./has_namespaces.ts
	// @require ./parse_event_name.ts
	function removeEvent(ele, name, namespaces, selector, callback) {
	    const cache = getEventsCache(ele);
	    if (!name) {
	        for (name in cache) {
	            removeEvent(ele, name, namespaces, selector, callback);
	        }
	    }
	    else if (cache[name]) {
	        cache[name] = cache[name].filter(([ns, sel, cb]) => {
	            if ((callback && cb.guid !== callback.guid) || !hasNamespaces(ns, namespaces) || (selector && selector !== sel))
	                return true;
	            ele.removeEventListener(name, cb);
	        });
	    }
	}
	fn.off = function (eventFullName, selector, callback) {
	    if (isUndefined(eventFullName)) {
	        this.each((i, ele) => { removeEvent(ele); });
	    }
	    else if (!isString(eventFullName)) {
	        for (const key in eventFullName) {
	            this.off(key, eventFullName[key]);
	        }
	    }
	    else {
	        if (isFunction(selector)) {
	            callback = selector;
	            selector = '';
	        }
	        each(getSplitValues(eventFullName), (i, eventFullName) => {
	            const [name, namespaces] = parseEventName(getEventNameBubbling(eventFullName));
	            this.each((i, ele) => { removeEvent(ele, name, namespaces, selector, callback); });
	        });
	    }
	    return this;
	};
	function on(eventFullName, selector, callback, _one) {
	    if (!isString(eventFullName)) {
	        for (const key in eventFullName) {
	            this.on(key, selector, eventFullName[key]);
	        }
	        return this;
	    }
	    if (isFunction(selector)) {
	        callback = selector;
	        selector = '';
	    }
	    each(getSplitValues(eventFullName), (i, eventFullName) => {
	        const [name, namespaces] = parseEventName(getEventNameBubbling(eventFullName));
	        this.each((i, ele) => {
	            const finalCallback = function (event) {
	                if (event.namespace && !hasNamespaces(namespaces, event.namespace.split(eventsNamespacesSeparator)))
	                    return;
	                let thisArg = ele;
	                if (selector) {
	                    let target = event.target;
	                    while (!matches(target, selector)) {
	                        if (target === ele)
	                            return;
	                        target = target.parentNode;
	                        if (!target)
	                            return;
	                    }
	                    thisArg = target;
	                    event.___cd = true; // Delegate
	                }
	                if (event.___cd) {
	                    Object.defineProperty(event, 'currentTarget', {
	                        configurable: true,
	                        get() {
	                            return thisArg;
	                        }
	                    });
	                }
	                const returnValue = callback.call(thisArg, event, event.data);
	                if (_one) {
	                    removeEvent(ele, name, namespaces, selector, finalCallback);
	                }
	                if (returnValue === false) {
	                    event.preventDefault();
	                    event.stopPropagation();
	                }
	            };
	            finalCallback.guid = callback.guid = (callback.guid || cash.guid++);
	            addEvent(ele, name, namespaces, selector, finalCallback);
	        });
	    });
	    return this;
	}
	fn.on = on;
	function one(eventFullName, selector, callback) {
	    return this.on(eventFullName, selector, callback, true);
	}
	fn.one = one;
	fn.ready = function (callback) {
	    if (doc.readyState !== 'loading') {
	        callback(cash);
	    }
	    else {
	        doc.addEventListener('DOMContentLoaded', () => { callback(cash); });
	    }
	    return this;
	};
	fn.trigger = function (event, data) {
	    if (isString(event)) {
	        const [name, namespaces] = parseEventName(event), type = eventsMouseRe.test(name) ? 'MouseEvents' : 'HTMLEvents';
	        event = doc.createEvent(type);
	        event.initEvent(name, true, true);
	        event.namespace = namespaces.join(eventsNamespacesSeparator);
	    }
	    event.data = data;
	    const isEventFocus = (event.type in eventsFocus);
	    return this.each((i, ele) => {
	        if (isEventFocus && isFunction(ele[event.type])) {
	            ele[event.type]();
	        }
	        else {
	            ele.dispatchEvent(event);
	        }
	    });
	};
	// @optional ./off.ts
	// @optional ./on.ts
	// @optional ./one.ts
	// @optional ./ready.ts
	// @optional ./trigger.ts
	// @require core/pluck.ts
	// @require core/variables.ts
	function getValue(ele) {
	    if (ele.multiple && ele.options)
	        return pluck(filter.call(ele.options, option => option.selected && !option.disabled && !option.parentNode.disabled), 'value');
	    return ele.value || '';
	}
	const queryEncodeSpaceRe = /%20/g;
	function queryEncode(prop, value) {
	    return `&${encodeURIComponent(prop)}=${encodeURIComponent(value).replace(queryEncodeSpaceRe, '+')}`;
	}
	const skippableRe = /file|reset|submit|button|image/i, checkableRe = /radio|checkbox/i;
	fn.serialize = function () {
	    let query = '';
	    this.each((i, ele) => {
	        each(ele.elements || [ele], (i, ele) => {
	            if (ele.disabled || !ele.name || ele.tagName === 'FIELDSET' || skippableRe.test(ele.type) || (checkableRe.test(ele.type) && !ele.checked))
	                return;
	            const value = getValue(ele);
	            if (!isUndefined(value)) {
	                const values = isArray(value) ? value : [value];
	                each(values, (i, value) => {
	                    query += queryEncode(ele.name, value);
	                });
	            }
	        });
	    });
	    return query.slice(1);
	};
	function val(value) {
	    if (isUndefined(value))
	        return this[0] && getValue(this[0]);
	    return this.each((i, ele) => {
	        if (ele.tagName === 'SELECT') {
	            const eleValue = isArray(value) ? value : (isNull(value) ? [] : [value]);
	            each(ele.options, (i, option) => {
	                option.selected = eleValue.indexOf(option.value) >= 0;
	            });
	        }
	        else {
	            ele.value = isNull(value) ? '' : value;
	        }
	    });
	}
	fn.val = val;
	fn.clone = function () {
	    return this.map((i, ele) => ele.cloneNode(true));
	};
	fn.detach = function () {
	    return this.each((i, ele) => {
	        if (ele.parentNode) {
	            ele.parentNode.removeChild(ele);
	        }
	    });
	};
	const fragmentRe = /^\s*<(\w+)[^>]*>/, singleTagRe = /^\s*<(\w+)\s*\/?>(?:<\/\1>)?\s*$/;
	const containers = {
	    '*': div,
	    tr: tbody,
	    td: tr,
	    th: tr,
	    thead: table,
	    tbody: table,
	    tfoot: table
	};
	function parseHTML(html) {
	    if (!isString(html))
	        return [];
	    if (singleTagRe.test(html))
	        return [createElement(RegExp.$1)];
	    const fragment = fragmentRe.test(html) && RegExp.$1, container = containers[fragment] || containers['*'];
	    container.innerHTML = html;
	    return cash(container.childNodes).detach().get();
	}
	cash.parseHTML = parseHTML;
	fn.empty = function () {
	    return this.each((i, ele) => {
	        while (ele.firstChild) {
	            ele.removeChild(ele.firstChild);
	        }
	    });
	};
	function html(html) {
	    if (isUndefined(html))
	        return this[0] && this[0].innerHTML;
	    return this.each((i, ele) => { ele.innerHTML = html; });
	}
	fn.html = html;
	fn.remove = function () {
	    return this.detach().off();
	};
	function text(text) {
	    if (isUndefined(text))
	        return this[0] ? this[0].textContent : '';
	    return this.each((i, ele) => { ele.textContent = text; });
	}
	fn.text = text;
	fn.unwrap = function () {
	    this.parent().each((i, ele) => {
	        const $ele = cash(ele);
	        $ele.replaceWith($ele.children());
	    });
	    return this;
	};
	fn.offset = function () {
	    const ele = this[0];
	    if (!ele)
	        return;
	    const rect = ele.getBoundingClientRect();
	    return {
	        top: rect.top + win.pageYOffset - docEle.clientTop,
	        left: rect.left + win.pageXOffset - docEle.clientLeft
	    };
	};
	fn.offsetParent = function () {
	    return cash(this[0] && this[0].offsetParent);
	};
	fn.position = function () {
	    const ele = this[0];
	    if (!ele)
	        return;
	    return {
	        left: ele.offsetLeft,
	        top: ele.offsetTop
	    };
	};
	fn.children = function (comparator) {
	    return filtered(cash(unique(pluck(this, ele => ele.children))), comparator);
	};
	fn.contents = function () {
	    return cash(unique(pluck(this, ele => ele.tagName === 'IFRAME' ? [ele.contentDocument] : ele.childNodes)));
	};
	fn.find = function (selector) {
	    return cash(unique(pluck(this, ele => find(selector, ele))));
	};
	// @require core/variables.ts
	// @require collection/filter.ts
	// @require traversal/find.ts
	const HTMLCDATARe = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, scriptTypeRe = /^$|^module$|\/(java|ecma)script/i, scriptAttributes = ['type', 'src', 'nonce', 'noModule'];
	function evalScripts(node, doc) {
	    const collection = cash(node);
	    collection.filter('script').add(collection.find('script')).each((i, ele) => {
	        if (scriptTypeRe.test(ele.type) && docEle.contains(ele)) { // The script type is supported // The element is attached to the DOM // Using `documentElement` for broader browser support
	            const script = createElement('script');
	            script.text = ele.textContent.replace(HTMLCDATARe, '');
	            each(scriptAttributes, (i, attr) => {
	                if (ele[attr])
	                    script[attr] = ele[attr];
	            });
	            doc.head.insertBefore(script, null);
	            doc.head.removeChild(script);
	        }
	    });
	}
	// @require ./eval_scripts.ts
	function insertElement(anchor, target, left, inside) {
	    if (inside) { // prepend/append
	        anchor.insertBefore(target, left ? anchor.firstElementChild : null);
	    }
	    else { // before/after
	        anchor.parentNode.insertBefore(target, left ? anchor : anchor.nextElementSibling);
	    }
	    evalScripts(target, anchor.ownerDocument);
	}
	// @require ./insert_element.ts
	function insertSelectors(selectors, anchors, inverse, left, inside, reverseLoop1, reverseLoop2, reverseLoop3) {
	    each(selectors, (si, selector) => {
	        each(cash(selector), (ti, target) => {
	            each(cash(anchors), (ai, anchor) => {
	                const anchorFinal = inverse ? target : anchor, targetFinal = inverse ? anchor : target;
	                insertElement(anchorFinal, !ai ? targetFinal : targetFinal.cloneNode(true), left, inside);
	            }, reverseLoop3);
	        }, reverseLoop2);
	    }, reverseLoop1);
	    return anchors;
	}
	fn.after = function () {
	    return insertSelectors(arguments, this, false, false, false, true, true);
	};
	fn.append = function () {
	    return insertSelectors(arguments, this, false, false, true);
	};
	fn.appendTo = function (selector) {
	    return insertSelectors(arguments, this, true, false, true);
	};
	fn.before = function () {
	    return insertSelectors(arguments, this, false, true);
	};
	fn.insertAfter = function (selector) {
	    return insertSelectors(arguments, this, true, false, false, false, false, true);
	};
	fn.insertBefore = function (selector) {
	    return insertSelectors(arguments, this, true, true);
	};
	fn.prepend = function () {
	    return insertSelectors(arguments, this, false, true, true, true, true);
	};
	fn.prependTo = function (selector) {
	    return insertSelectors(arguments, this, true, true, true, false, false, true);
	};
	fn.replaceWith = function (selector) {
	    return this.before(selector).remove();
	};
	fn.replaceAll = function (selector) {
	    cash(selector).replaceWith(this);
	    return this;
	};
	fn.wrapAll = function (selector) {
	    let structure = cash(selector), wrapper = structure[0];
	    while (wrapper.children.length)
	        wrapper = wrapper.firstElementChild;
	    this.first().before(structure);
	    return this.appendTo(wrapper);
	};
	fn.wrap = function (selector) {
	    return this.each((i, ele) => {
	        const wrapper = cash(selector)[0];
	        cash(ele).wrapAll(!i ? wrapper : wrapper.cloneNode(true));
	    });
	};
	fn.wrapInner = function (selector) {
	    return this.each((i, ele) => {
	        const $ele = cash(ele), contents = $ele.contents();
	        contents.length ? contents.wrapAll(selector) : $ele.append(selector);
	    });
	};
	fn.has = function (selector) {
	    const comparator = isString(selector)
	        ? (i, ele) => find(selector, ele).length
	        : (i, ele) => ele.contains(selector);
	    return this.filter(comparator);
	};
	fn.is = function (comparator) {
	    const compare = getCompareFunction(comparator);
	    return some.call(this, (ele, i) => compare.call(ele, i, ele));
	};
	fn.next = function (comparator, _all) {
	    return filtered(cash(unique(pluck(this, 'nextElementSibling', _all))), comparator);
	};
	fn.nextAll = function (comparator) {
	    return this.next(comparator, true);
	};
	fn.not = function (comparator) {
	    const compare = getCompareFunction(comparator);
	    return this.filter((i, ele) => !compare.call(ele, i, ele));
	};
	fn.parent = function (comparator) {
	    return filtered(cash(unique(pluck(this, 'parentNode'))), comparator);
	};
	fn.index = function (selector) {
	    const child = selector ? cash(selector)[0] : this[0], collection = selector ? this : cash(child).parent().children();
	    return indexOf.call(collection, child);
	};
	fn.closest = function (comparator) {
	    const filtered = this.filter(comparator);
	    if (filtered.length)
	        return filtered;
	    const $parent = this.parent();
	    if (!$parent.length)
	        return filtered;
	    return $parent.closest(comparator);
	};
	fn.parents = function (comparator) {
	    return filtered(cash(unique(pluck(this, 'parentElement', true))), comparator);
	};
	fn.prev = function (comparator, _all) {
	    return filtered(cash(unique(pluck(this, 'previousElementSibling', _all))), comparator);
	};
	fn.prevAll = function (comparator) {
	    return this.prev(comparator, true);
	};
	fn.siblings = function (comparator) {
	    return filtered(cash(unique(pluck(this, ele => cash(ele).parent().children().not(ele)))), comparator);
	};

	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);
	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    enumerableOnly && (symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    })), keys.push.apply(keys, symbols);
	  }
	  return keys;
	}
	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = null != arguments[i] ? arguments[i] : {};
	    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
	      _defineProperty(target, key, source[key]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
	      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	    });
	  }
	  return target;
	}
	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  }, _typeof(obj);
	}
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
	  }
	}
	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  Object.defineProperty(Constructor, "prototype", {
	    writable: false
	  });
	  return Constructor;
	}
	function _defineProperty(obj, key, value) {
	  key = _toPropertyKey(key);
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}
	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}
	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}
	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	}
	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}
	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;
	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	  return arr2;
	}
	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	function _createForOfIteratorHelper(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
	  if (!it) {
	    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	      if (it) o = it;
	      var i = 0;
	      var F = function () {};
	      return {
	        s: F,
	        n: function () {
	          if (i >= o.length) return {
	            done: true
	          };
	          return {
	            done: false,
	            value: o[i++]
	          };
	        },
	        e: function (e) {
	          throw e;
	        },
	        f: F
	      };
	    }
	    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }
	  var normalCompletion = true,
	    didErr = false,
	    err;
	  return {
	    s: function () {
	      it = it.call(o);
	    },
	    n: function () {
	      var step = it.next();
	      normalCompletion = step.done;
	      return step;
	    },
	    e: function (e) {
	      didErr = true;
	      err = e;
	    },
	    f: function () {
	      try {
	        if (!normalCompletion && it.return != null) it.return();
	      } finally {
	        if (didErr) throw err;
	      }
	    }
	  };
	}
	function _toPrimitive(input, hint) {
	  if (typeof input !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];
	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (typeof res !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (hint === "string" ? String : Number)(input);
	}
	function _toPropertyKey(arg) {
	  var key = _toPrimitive(arg, "string");
	  return typeof key === "symbol" ? key : String(key);
	}

	// tslint:disable variable-name ban-types no-empty
	var levels = ['error', 'warn', 'info', 'debug', 'trace'];
	var Log = /*#__PURE__*/function () {
	  function Log() {
	    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    _classCallCheck(this, Log);
	    this.console = window.console;
	    this.level = level;
	    this.prefix = prefix;
	    this.buildLogFunctions();
	  }
	  _createClass(Log, [{
	    key: "shouldLog",
	    value: function shouldLog(level) {
	      return level <= this.level;
	    }
	    /**
	     * Sets the logging level
	     *
	     * @param level logging level to change the logger into
	     */
	  }, {
	    key: "setLoggingLevel",
	    value: function setLoggingLevel(level) {
	      this.level = typeof level === 'string' ? levels.indexOf(level.toLowerCase()) + 1 : level || 0 /* NONE */;
	      this.buildLogFunctions();
	    }
	  }, {
	    key: "getLoggingLevel",
	    value: function getLoggingLevel() {
	      return this.level;
	    }
	    /**
	     *
	     * sets the logging level so that all log lines will be logged with as such
	     *
	     * `[INFO]({PREFIX}): ...`
	     *
	     * @param {string} prefix logging prefix
	     */
	  }, {
	    key: "setPrefix",
	    value: function setPrefix(prefix) {
	      this.prefix = prefix;
	      this.buildLogFunctions();
	    }
	  }, {
	    key: "getPrefix",
	    value: function getPrefix() {
	      return this.prefix;
	    }
	  }, {
	    key: "buildLogFunctions",
	    value: function buildLogFunctions() {
	      var _this = this;
	      levels.forEach(function (value, i) {
	        var level = levels[i];
	        _this[level] = _this.shouldLog(i + 1) ? _this.getLogFn(level) : function () {};
	      });
	    }
	  }, {
	    key: "getLogFn",
	    value: function getLogFn(consoleMethod) {
	      return Function.prototype.bind.call(this.console.log, this.console, "[".concat(consoleMethod.toUpperCase(), "]").concat(this.prefix ? '(' + this.prefix + ')' : '', ":"));
	    }
	  }]);
	  return Log;
	}();
	function setLoggingLevel(level) {
	  Logger.setLoggingLevel(level);
	}
	function getLoggingLevel() {
	  return Logger.getLoggingLevel();
	}
	var Logger = new Log();

	var CustomEvents;
	(function (CustomEvents) {
	  CustomEvents["OnEventSend"] = "interactions:onEventSend";
	  CustomEvents["OnBeforeEventSend"] = "interactions:onBeforeEventSend";
	  CustomEvents["OnException"] = "interactions:onException";
	  CustomEvents["OnPageMatchStatusUpdated"] = "interactions:onPageMatchStatusUpdated";
	  CustomEvents["OnInit"] = "interactions:onInit";
	  CustomEvents["OnInitSitemap"] = "interactions:onInitSitemap";
	  CustomEvents["OnShutDown"] = "interactions:onShutDown";
	  CustomEvents["OnSetAnonymousId"] = "interactions:onSetAnonymousId";
	  CustomEvents["OnResetAnonymousId"] = "interactions:onResetAnonymousId";
	  CustomEvents["OnClearPersistedIdentities"] = "interactions:onClearPersistedIdentities";
	  CustomEvents["OnClearCookie"] = "interactions:onClearCookie";
	  CustomEvents["OnConsentRevoke"] = "interactions:onConsentRevoke";
	  CustomEvents["OnBeforeInit"] = "interactions:onBeforeInit";
	})(CustomEvents || (CustomEvents = {}));
	// Sitemap re-init catalog rejection
	var SITEMAP_REINIT = "sitemap_reinit";
	// Channel
	var DEFAULT_CHANNEL = "Web";
	var IDENTITY_COOKIE_PREFIX = '_sfid';
	var STORAGE_INFO = {
	  anonymousId: {
	    ids: {
	      // No local storage ID for visitor cookie
	    },
	    timeoutDays: 730 // 2 years
	  }
	};

	function sha1 (r) {
	  var o,
	    e,
	    t,
	    f,
	    n,
	    a = [],
	    c = [e = 1732584193, t = 4023233417, ~e, ~t, 3285377520],
	    u = [],
	    d = unescape(encodeURI(r)) + "",
	    g = d.length;
	  for (u[r = --g / 4 + 2 | 15] = 8 * g; ~g;) u[g >> 2] |= d.charCodeAt(g) << 8 * ~g--;
	  for (o = g = 0; o < r; o += 16) {
	    for (e = c; g < 80; e = [e[4] + (a[g] = g < 16 ? ~~u[o + g] : 2 * d | d < 0) + 1518500249 + [t & f | ~t & n, d = 341275144 + (t ^ f ^ n), 882459459 + (t & f | t & n | f & n), d + 1535694389][g++ / 5 >> 2] + ((d = e[0]) << 5 | d >>> 27), d, t << 30 | t >>> 2, f, n]) d = a[g - 3] ^ a[g - 8] ^ a[g - 14] ^ a[g - 16], t = e[1], f = e[2], n = e[3];
	    for (g = 5; g;) c[--g] += e[g];
	  }
	  for (d = ""; g < 40;) d += (c[g >> 3] >> 4 * (7 - g++) & 15).toString(16);
	  return d;
	}

	// XXX: this is a workaround for how typescript/jest both import the sha1 package differently
	//
	//      here's the situation - the sha1 package contains both an ES6 module (index.mjs) and a CommonJS
	//      module (index.js) which leads to the following behaviors:
	//      * typescript compilation - the MJS version is resolved which uses `export default sha1`
	//      * jest transformation - the CJS version is resolved which uses `module.exports = sha1`
	//
	//      i'm not sure if this can be worked around via config or it's just a weird edge case around
	//      the transition towards ES6 compliant support in libraries.
	var sha1$1 = sha1.default ? sha1.default : sha1;

	/**
	 * A sha1 of the current account, dataset and cookieDomainHash joined with periods
	 */
	var cookieHash;
	var cookieDomain = window.location.hostname;
	var generateCookieDomainHash = function generateCookieDomainHash() {
	  return sha1$1(cookieDomain + '/').slice(0, 4); // 4 hexits = 16 bits
	};
	// See convertMcisVisitorToSalesforceIdentity in MCIS module
	var getCookieDomain = function getCookieDomain() {
	  return cookieDomain;
	};
	var setCookieDomain = function setCookieDomain(domain) {
	  cookieDomain = domain;
	  setCookieHash();
	};
	var setCookieHash = function setCookieHash() {
	  cookieHash = sha1$1("".concat(generateCookieDomainHash())).slice(0, 4);
	};
	var getCookieName = function getCookieName() {
	  return "".concat(IDENTITY_COOKIE_PREFIX, "_").concat(cookieHash);
	};

	var secureCookie;
	// jsCookie is a vanilla javascript library, so we set the type definitions for js-cookie 2.2 from '@types/js-cookie'
	var Cookie = jsCookie;
	document.addEventListener(CustomEvents.OnClearCookie, function (event) {
	  var options = event.detail && event.detail.options || {};
	  if (options.domain) {
	    setCookieDomain(event.detail.options.domain);
	  }
	  remove(_objectSpread2({
	    domain: getCookieDomain()
	  }, options));
	});
	var read = function read() {
	  return Cookie.getJSON(getCookieName());
	};
	var write = function write(cookieValue, daysToExpire) {
	  if (secureCookie) {
	    Cookie.set(getCookieName(), cookieValue, {
	      expires: daysToExpire,
	      domain: getCookieDomain(),
	      secure: true
	    });
	  } else {
	    Cookie.set(getCookieName(), cookieValue, {
	      expires: daysToExpire,
	      domain: getCookieDomain()
	    });
	  }
	  if (!Cookie.get(getCookieName())) {
	    Logger.warn("Web SDK cookie (_sfid) could not be set. This is possibly due to a restricted top level domain. See https://publicsuffix.org/learn/ for more information.");
	  }
	};
	var remove = function remove(options) {
	  Cookie.remove(getCookieName(), options);
	};
	var writeIdentityCookie = function writeIdentityCookie(identityCookie) {
	  Cookies.write(identityCookie, STORAGE_INFO.anonymousId.timeoutDays);
	};
	var writeAnonymousIdToCookie = function writeAnonymousIdToCookie(anonymousId) {
	  writeIdentityCookie(_objectSpread2(_objectSpread2({}, read()), {}, {
	    anonymousId: anonymousId
	  }));
	};
	var writeConsentsToCookie = function writeConsentsToCookie(consents) {
	  writeIdentityCookie(_objectSpread2(_objectSpread2({}, read()), {}, {
	    consents: consents
	  }));
	};
	var setSecureAttributeOnCookie = function setSecureAttributeOnCookie(setSecureCookieAttribute) {
	  secureCookie = setSecureCookieAttribute;
	};
	var Cookies = {
	  read: read,
	  write: write,
	  remove: remove
	};

	// The only thing we have to fear is fear itself, and:
	var spiders = [/bot/i, /spider/i, /facebookexternalhit/i, /simplepie/i, /yahooseeker/i, /embedly/i, /quora link preview/i, /outbrain/i, /vkshare/i, /monit/i, /Pingability/i, /Monitoring/i, /WinHttpRequest/i, /Apache-HttpClient/i, /getprismatic.com/i, /python-requests/i, /Twurly/i, /yandex/i, /browserproxy/i, /crawler/i, /Qwantify/i, /Yahoo! Slurp/i, /pinterest/i, /Tumblr\/14.0.835.186/i, /Tumblr Agent 14.0/i];
	var isSpider = function isSpider(ua) {
	  return spiders.some(function (spider) {
	    return spider.test(ua);
	  });
	};
	var userAgentIsRobot = function userAgentIsRobot() {
	  return isSpider(getUserAgent());
	};
	var getUserAgent = function getUserAgent() {
	  return window.navigator.userAgent || '';
	};
	var getNavigatorPlatform = function getNavigatorPlatform() {
	  return window.navigator.platform || '';
	};
	var isSafari = navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') == -1 && navigator.userAgent.indexOf('FxiOS') == -1;

	/* resolved locally */
	/**
	 * generateUuid
	 * @return {String} a pseudo-unique ID to fingerprint a user.
	 */
	function generateUuid() {
	  var dateTime = new Date().getTime;
	  var raw = getUserAgent() + getNavigatorPlatform() + dateTime + JSON.stringify({}) + Math.random();
	  return sha1$1(raw).slice(0, 16);
	}

	// TODO: Any good reason to have it be an object with an ID?
	// export interface AnonymousIdentity {
	//     id?: string;
	// }
	var anonymousId = "";
	document.addEventListener(CustomEvents.OnResetAnonymousId, function () {
	  Cookies.remove(); // TODO: probably need to pass options here?
	  loadAnonymousIdentity();
	});
	document.addEventListener(CustomEvents.OnSetAnonymousId, function (event) {
	  if (event.detail && event.detail.newAnonymousId) {
	    writeAnonymousIdToCookie(event.detail.newAnonymousId);
	  }
	});
	var getAnonymousId = function getAnonymousId() {
	  return anonymousId;
	};
	var setAnonymousId = function setAnonymousId(newAnonymousId) {
	  anonymousId = newAnonymousId;
	  if (newAnonymousId) {
	    document.dispatchEvent(new CustomEvent(CustomEvents.OnSetAnonymousId, {
	      detail: {
	        newAnonymousId: newAnonymousId
	      }
	    }));
	  } else {
	    Logger.warn('Attempted to setAnonymousId but not parameter is undefined');
	  }
	};
	var loadAnonymousIdentity = function loadAnonymousIdentity() {
	  if (!identityCookieExists()) {
	    setAnonymousId(generateUuid());
	    Logger.debug("Created new anonymous identity record. anonymousId: ".concat(getAnonymousId()));
	  } else {
	    var identityCookie = Cookies.read();
	    anonymousId = identityCookie.anonymousId;
	    // rewrite cookie to reset TTL and potential secure cookie attribute
	    setAnonymousId(anonymousId);
	    Logger.debug("Loaded anonymous identity record from cookie: ".concat(JSON.stringify(getAnonymousId())));
	  }
	  return getAnonymousId();
	};
	var identityCookieExists = function identityCookieExists() {
	  var identityCookie = Cookies.read();
	  return !!(identityCookie && _typeof(identityCookie) === "object" && Object.keys(identityCookie).length > 0);
	};

	var Signal = /*#__PURE__*/function () {
	  function Signal() {
	    _classCallCheck(this, Signal);
	    this.listeners = [];
	  }
	  _createClass(Signal, [{
	    key: "on",
	    value: function on(listener) {
	      var _this = this;
	      (this.listeners = this.listeners || []).push(listener);
	      return function () {
	        _this.listeners = _this.listeners.filter(function (i) {
	          return i !== listener;
	        });
	      };
	    }
	  }, {
	    key: "once",
	    value: function once(listener) {
	      var _this2 = this;
	      return this.on(function () {
	        _this2.unbindAll();
	        try {
	          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	          }
	          listener.apply(_this2, args);
	        } catch (e) {
	          Logger.error('Signal listener callback error: ' + e);
	        }
	      });
	    }
	  }, {
	    key: "emit",
	    value: function emit() {
	      var _this3 = this;
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	      this.listeners.length !== 0 && this.listeners.forEach(function (listener) {
	        try {
	          listener.apply(_this3, args);
	        } catch (e) {
	          Logger.error('Signal listener callback error: ' + e);
	        }
	      });
	    }
	  }, {
	    key: "unbindAll",
	    value: function unbindAll() {
	      this.listeners = [];
	    }
	  }]);
	  return Signal;
	}();
	var unbindMySignals = function unbindMySignals(typeWithSignals) {
	  Logger.debug('Unbinding all signals for type: ', typeWithSignals);
	  Object.keys(typeWithSignals).forEach(function (signal) {
	    if (typeWithSignals[signal].unbindAll) {
	      typeWithSignals[signal].unbindAll();
	    }
	  });
	};

	var Signals = /*#__PURE__*/_createClass(function Signals() {
	  _classCallCheck(this, Signals);
	});
	Signals.onEventSend = new Signal();
	Signals.onFireException = new Signal();
	Signals.onPageMatchStatusUpdated = new Signal();
	Signals.onInitSitemap = new Signal();
	Signals.unbindAll = function () {
	  unbindMySignals(Signals);
	};

	var sitemapState = {
	  result: {
	    currentPage: null,
	    matchedConfig: null,
	    matchStatus: null
	  },
	  config: {
	    pageTypes: []
	  }
	};
	var currentKey = null;
	var getSitemapConfig = function getSitemapConfig() {
	  return sitemapState.config;
	};
	var getSitemapResult = function getSitemapResult() {
	  return sitemapState.result;
	};
	var getCurrentSitemapKey = function getCurrentSitemapKey() {
	  return currentKey;
	};
	var setCurrentSitemapKey = function setCurrentSitemapKey(key) {
	  currentKey = key;
	};

	var MatchStatus;
	(function (MatchStatus) {
	  MatchStatus["Pending"] = "pending";
	  MatchStatus["Running"] = "running";
	  MatchStatus["Selected"] = "selected";
	  MatchStatus["Matched"] = "matched";
	  MatchStatus["Rejected"] = "rejected";
	})(MatchStatus || (MatchStatus = {}));

	var matchPageConfig = function matchPageConfig(pageConfigs) {
	  return new Promise(function (resolve, reject) {
	    var defaultPageConfig = sitemapState.config.pageTypeDefault;
	    if (defaultPageConfig) {
	      setDefaultPageConfigToPending(defaultPageConfig);
	    }
	    if (defaultPageConfig && !pageConfigs.length) {
	      selectPageMatchStatus(defaultPageConfig);
	      resolve(defaultPageConfig);
	      return;
	    }
	    setPageConfigsToPending(pageConfigs);
	    pageConfigs.map(function (pageConfig) {
	      isPageMatch(pageConfig).then(function (isMatch) {
	        if (isMatch) {
	          if (defaultPageConfig) {
	            rejectPageMatchStatus(defaultPageConfig);
	          }
	          selectPageMatchStatus(pageConfig);
	          resolve(pageConfig);
	        } else {
	          rejectPageMatchStatus(pageConfig);
	          if (!unresolvedPageMatchExists(pageConfigs)) {
	            if (defaultPageConfig) {
	              selectPageMatchStatus(defaultPageConfig);
	              resolve(defaultPageConfig);
	            } else {
	              reject("No matching page found");
	            }
	          }
	        }
	      }).catch(function (e) {
	        if (e !== SITEMAP_REINIT) Signals.onFireException.emit(new Error("isMatch failed while evaluating the ".concat(pageConfig.name, " page config")), 'Site-wide Javascript');
	      });
	    });
	  });
	};
	var removeOutstandingPageMatchResolvers = function removeOutstandingPageMatchResolvers() {
	  var state = sitemapState;
	  if (state.result.matchStatus) {
	    state.result.matchStatus.forEach(function (s) {
	      if (s.status === MatchStatus.Running) {
	        s._reject(SITEMAP_REINIT);
	      }
	    });
	    sitemapState.result.matchStatus = [];
	  }
	  Signals.onPageMatchStatusUpdated.emit(sitemapState.result.matchStatus);
	};
	var setPageConfigsToPending = function setPageConfigsToPending(pageConfigs) {
	  pageConfigs.forEach(function (config) {
	    handleUpdateResultMatchStatus({
	      pageName: config.name,
	      status: MatchStatus.Pending
	    });
	  });
	};
	var setDefaultPageConfigToPending = function setDefaultPageConfigToPending(defaultPageConfig) {
	  handleUpdateResultMatchStatus({
	    pageName: defaultPageConfig.name,
	    status: MatchStatus.Pending
	  });
	};
	var selectPageMatchStatus = function selectPageMatchStatus(pageConfig) {
	  handleUpdateResultMatchStatus({
	    pageName: pageConfig.name,
	    endTime: Date.now(),
	    status: sitemapState.result.matchStatus.find(function (s) {
	      return s.status === MatchStatus.Selected;
	    }) ? MatchStatus.Matched : MatchStatus.Selected
	  });
	};
	var rejectPageMatchStatus = function rejectPageMatchStatus(pageConfig) {
	  handleUpdateResultMatchStatus({
	    pageName: pageConfig.name,
	    status: MatchStatus.Rejected,
	    endTime: Date.now()
	  });
	};
	var unresolvedPageMatchExists = function unresolvedPageMatchExists(pageConfigs) {
	  var unresolvedMatches = sitemapState.result.matchStatus.filter(function (pageConfig) {
	    return pageConfig.status === MatchStatus.Rejected;
	  }, 0).length;
	  return unresolvedMatches < pageConfigs.length;
	};
	var isPageMatch = function isPageMatch(pageConfig) {
	  return new Promise(function (resolve, reject) {
	    handleUpdateResultMatchStatus({
	      pageName: pageConfig.name,
	      status: MatchStatus.Running,
	      startTime: Date.now(),
	      _reject: reject
	    });
	    if (typeof pageConfig.isMatch === 'function') {
	      var funcValue = pageConfig.isMatch();
	      if (_typeof(funcValue) === 'object') {
	        funcValue.then(function (isMatch) {
	          resolve(isMatch);
	        }).catch(function () {
	          // TODO: log this, do anything else?
	        });
	      } else {
	        resolve(funcValue);
	      }
	    } else {
	      Signals.onFireException.emit(new Error("isMatch failed while evaluating the ".concat(pageConfig.name, " page config. isMatch must be a function.")), 'Site-wide Javascript');
	    }
	  });
	};
	var handleUpdateResultMatchStatus = function handleUpdateResultMatchStatus(matchStatus) {
	  sitemapState.result.matchStatus = [].concat(_toConsumableArray(sitemapState.result.matchStatus || []), [matchStatus]);
	  Signals.onPageMatchStatusUpdated.emit(sitemapState.result.matchStatus);
	};

	/*
	 * Copyright (C) 2010-2019 Evergage, Inc.
	 * All rights reserved.
	 */
	var CatalogObjectInteractionName;
	(function (CatalogObjectInteractionName) {
	  CatalogObjectInteractionName["ViewCatalogObject"] = "View Catalog Object";
	  CatalogObjectInteractionName["ViewCatalogObjectDetail"] = "View Catalog Object Detail";
	  CatalogObjectInteractionName["QuickViewCatalogObject"] = "Quick View Catalog Object";
	  CatalogObjectInteractionName["ShareCatalogObject"] = "Share Catalog Object";
	  CatalogObjectInteractionName["ReviewCatalogObject"] = "Review Catalog Object";
	  CatalogObjectInteractionName["CommentCatalogObject"] = "Comment Catalog Object";
	  CatalogObjectInteractionName["FavoriteCatalogObject"] = "Favorite Catalog Object";
	})(CatalogObjectInteractionName || (CatalogObjectInteractionName = {}));
	/* CART */
	var CartInteractionName;
	(function (CartInteractionName) {
	  CartInteractionName["AddToCart"] = "Add To Cart";
	  CartInteractionName["RemoveFromCart"] = "Remove From Cart";
	  CartInteractionName["ReplaceCart"] = "Replace Cart";
	})(CartInteractionName || (CartInteractionName = {}));
	var OrderInteractionName;
	(function (OrderInteractionName) {
	  OrderInteractionName["Purchase"] = "Purchase";
	  OrderInteractionName["Preorder"] = "Preorder";
	  OrderInteractionName["Cancel"] = "Cancel";
	  OrderInteractionName["Ship"] = "Ship";
	  OrderInteractionName["Deliver"] = "Deliver";
	  OrderInteractionName["Return"] = "Return";
	  OrderInteractionName["Exchange"] = "Exchange";
	})(OrderInteractionName || (OrderInteractionName = {}));
	var MetadataUpdateInteractionName;
	(function (MetadataUpdateInteractionName) {
	  MetadataUpdateInteractionName["MetadataUpdate"] = "MetadataUpdate";
	})(MetadataUpdateInteractionName || (MetadataUpdateInteractionName = {}));
	var ConsentPurpose;
	(function (ConsentPurpose) {
	  ConsentPurpose["Tracking"] = "Tracking";
	})(ConsentPurpose || (ConsentPurpose = {}));
	var ConsentStatus;
	(function (ConsentStatus) {
	  ConsentStatus["OptIn"] = "Opt In";
	  ConsentStatus["OptOut"] = "Opt Out";
	})(ConsentStatus || (ConsentStatus = {}));

	/**
	 *
	 * #### Basic usage example:
	 * ```javascript
	 * try {
	 *     // do something
	 * } catch(e) {
	 *     SalesforceInteractions.sendException(e, "Login");
	 * }
	 * ```
	 *
	 *
	 * @param exception An Error object for the exception
	 * @param errorSection A tag for categorizing the error
	 * @param dontLogException Whether to send but silently not log the exception
	 *
	 */
	var sendException = function sendException(exception, errorSection, dontLogException) {
	  Signals.onFireException.emit(exception, errorSection);
	  Logger.warn('sendException', {
	    event: event,
	    errorSection: errorSection
	  });
	};

	var currentConsents = [];
	var getConsents = function getConsents() {
	  return currentConsents;
	};
	var findCurrentConsent = function findCurrentConsent(consentToFind) {
	  return currentConsents.find(function (currentConsent) {
	    return consentToFind.purpose == currentConsent.consent.purpose;
	  });
	};
	var updateConsents = function updateConsents(consents) {
	  handleConsentsUpdate(consents, true);
	};
	var handleConsentsUpdate = function handleConsentsUpdate(consents, sendRevoke) {
	  if (Array.isArray(consents)) {
	    consents.forEach(function (c) {
	      handleSingleConsent(c, sendRevoke);
	    });
	  } else {
	    handleSingleConsent(consents, sendRevoke);
	  }
	  writeConsentsToCookie(currentConsents);
	};
	var handleSingleConsent = function handleSingleConsent(consent, sendRevoke) {
	  if (!validateConsent(consent)) {
	    return;
	  }
	  var foundConsent = findCurrentConsent(consent);
	  if (foundConsent) {
	    handleExistingConsent(foundConsent, consent, sendRevoke);
	  } else {
	    handleNewConsent(consent, sendRevoke);
	  }
	};
	var handleExistingConsent = function handleExistingConsent(currentConsent, newConsent, sendRevoke) {
	  var preUpdateStatus = currentConsent.consent.status;
	  if (currentConsent.consent.status != newConsent.status || currentConsent.consent.provider != newConsent.provider) {
	    currentConsent.consent = newConsent;
	    currentConsent.lastUpdateTime = new Date().toISOString();
	  }
	  if (sendRevoke && preUpdateStatus == ConsentStatus.OptIn && newConsent.status == ConsentStatus.OptOut) {
	    revokeConsent(currentConsent);
	  }
	};
	var handleNewConsent = function handleNewConsent(newConsent, sendRevoke) {
	  var consentToStore = {
	    consent: newConsent,
	    lastUpdateTime: new Date().toISOString()
	  };
	  currentConsents.push(consentToStore);
	  if (sendRevoke && consentToStore.consent.status == ConsentStatus.OptOut) {
	    revokeConsent(consentToStore);
	  }
	};
	var validateConsent = function validateConsent(consent) {
	  if (consent && _typeof(consent) == "object" && consent.purpose && consent.provider && consent.status) {
	    return true;
	  } else {
	    sendException(new Error("Invalid consent, check that consent is a valid object and all fields are defined: ".concat(JSON.stringify(consent))), "Salesforce Web SDK");
	    return false;
	  }
	};
	var revokeConsent = function revokeConsent(revokedConsent) {
	  document.dispatchEvent(new CustomEvent(CustomEvents.OnConsentRevoke, {
	    detail: {
	      revokedConsent: revokedConsent
	    }
	  }));
	};
	var setConsentLastSentTimes = function setConsentLastSentTimes(consents) {
	  var date = new Date().toISOString();
	  consents.forEach(function (consent) {
	    var foundConsent = findCurrentConsent(consent);
	    foundConsent.lastSentTime = date;
	  });
	  writeConsentsToCookie(currentConsents);
	};
	// do not updates consents, and potentially send a consent revoke event, unless
	// an opt-in conset exists in either the consents passed into init or the consents stored in the cookie
	var resolveConsents = function resolveConsents(consents) {
	  loadConsentFromCookie();
	  Promise.resolve(consents).then(function (resolvedConsents) {
	    if (resolvedConsents && resolvedConsents.length > 0) {
	      updateConsents(resolvedConsents);
	    }
	  });
	};
	var loadConsentFromCookie = function loadConsentFromCookie() {
	  var identityCookie = Cookies.read();
	  if (identityCookie) {
	    currentConsents = identityCookie.consents || [];
	  }
	};
	var consentOptInExists$1 = function consentOptInExists(consents) {
	  return consents.findIndex(function (consent) {
	    return consent.status == ConsentStatus.OptIn;
	  }) >= 0;
	};
	var currentConsentOptInExists = function currentConsentOptInExists() {
	  return consentOptInExists$1(currentConsents.map(function (currentConsent) {
	    return currentConsent.consent;
	  }));
	};

	var prepareEvent = function prepareEvent(event) {
	  prepareSourcePayload(event);
	  prepareUserPayload(event);
	  prepareConsentPayload(event);
	};
	var prepareSourcePayload = function prepareSourcePayload(event) {
	  event.source = event.source || {};
	  event.source = _objectSpread2(_objectSpread2({}, event.source || {}), {}, {
	    pageType: event.source.pageType || getPageTypeFromSitemapState(),
	    url: event.source.url || window.location.href,
	    urlReferrer: event.source.urlReferrer || document.referrer,
	    channel: event.source.channel || DEFAULT_CHANNEL
	  });
	};
	var prepareUserPayload = function prepareUserPayload(event) {
	  event.user = _objectSpread2(_objectSpread2({}, event.user || {}), {}, {
	    anonymousId: getAnonymousId()
	  });
	};
	var prepareConsentPayload = function prepareConsentPayload(event) {
	  if (event.consents) {
	    handleConsentsUpdate(event.consents, false);
	  }
	  event.consents = getConsents().filter(function (consent) {
	    return !consent.lastSentTime || new Date(consent.lastUpdateTime) >= new Date(consent.lastSentTime);
	  }).map(function (consentWithMetadata) {
	    return consentWithMetadata.consent;
	  });
	  setConsentLastSentTimes(event.consents);
	};
	var getPageTypeFromSitemapState = function getPageTypeFromSitemapState() {
	  if (sitemapState.result.currentPage && sitemapState.result.currentPage.source) {
	    return sitemapState.result.currentPage.source.pageType;
	  }
	};

	document.addEventListener(CustomEvents.OnConsentRevoke, function (event) {
	  if (event.detail && event.detail.revokedConsent) {
	    var consentRevokeEvent = {
	      interaction: {
	        name: MetadataUpdateInteractionName.MetadataUpdate
	      },
	      consents: [event.detail.revokedConsent.consent]
	    };
	    sendConsentRevokeEvent(consentRevokeEvent);
	  }
	});
	var sendEvent = function sendEvent(event) {
	  return sendEventWithConsentCheck(event, currentConsentOptInExists).catch(function (error) {
	    Logger.error(error.message);
	    Signals.onFireException.emit(error, 'Site-wide JavaScript');
	    return event;
	  });
	};
	var sendConsentRevokeEvent = function sendConsentRevokeEvent(event) {
	  sendEventWithConsentCheck(event, function () {
	    return true;
	  }).then(function () {
	    return Logger.debug('Consent revoked');
	  }, function (error) {
	    return Signals.onFireException.emit(error, 'Site-wide JavaScript');
	  });
	};
	var sendEventWithConsentCheck = function sendEventWithConsentCheck(event, consentChecker) {
	  event = handleOnActionEvent(event);
	  prepareEvent(event);
	  if (consentChecker && !consentChecker()) {
	    Logger.debug('No opt-in consents provided. Event will still be dispatched.');
	  }
	  Logger.debug('Sent event: ', event);
	  Signals.onEventSend.emit(event);
	  return Promise.resolve(event);
	};
	var handleOnActionEvent = function handleOnActionEvent(event) {
	  event = matchedConfigOnActionEvent(event);
	  event = globalOnActionEvent(event);
	  return event;
	};
	var matchedConfigOnActionEvent = function matchedConfigOnActionEvent(event) {
	  var matchedConfig = sitemapState.result.matchedConfig;
	  try {
	    event = matchedConfig && matchedConfig.onActionEvent ? matchedConfig.onActionEvent(event) : event;
	    if (_typeof(event) === 'object') {
	      return event;
	    } else {
	      Signals.onFireException.emit(new Error("onActionEvent failed for the ".concat(sitemapState.result.matchedConfig.name, " page config. Must return an object or null.")), 'Site-wide Javascript');
	    }
	  } catch (e) {
	    Signals.onFireException.emit(new Error("onActionEvent failed for the ".concat(sitemapState.result.matchedConfig.name, " page config. ").concat(e.message, ".")), 'Site-wide Javascript');
	  }
	};
	var globalOnActionEvent = function globalOnActionEvent(event) {
	  var siteMapConfig = sitemapState.config;
	  try {
	    event = siteMapConfig.global && siteMapConfig.global.onActionEvent ? siteMapConfig.global.onActionEvent(event) : event;
	    if (_typeof(event) === 'object') {
	      return event;
	    } else {
	      Signals.onFireException.emit(new Error("onActionEvent failed for the global page config. Must return an object or null."), 'Site-wide Javascript');
	    }
	  } catch (e) {
	    Signals.onFireException.emit(new Error("onActionEvent failed for the global page config. ".concat(e.message, ".")), 'Site-wide Javascript');
	  }
	};

	var processInteraction = function processInteraction(pageConfig) {
	  return new Promise(function (resolve, reject) {
	    Signals.onInitSitemap.once(function () {
	      return reject(SITEMAP_REINIT);
	    });
	    var interaction = {
	      name: null
	    };
	    var interactionConfigPromises = [];
	    Object.keys(pageConfig.interaction).forEach(function (key) {
	      var valueFromConfig = pageConfig.interaction[key];
	      var interactionConfigPromise = resolveAndCleanValue(valueFromConfig, key).then(function (resolvedValue) {
	        interaction[key] = resolvedValue;
	      });
	      interactionConfigPromises.push(interactionConfigPromise);
	    });
	    Promise.all(interactionConfigPromises).then(function () {
	      resolve(interaction);
	    }).catch(function (e) {
	      Signals.onFireException.emit(new Error("Catalog object interaction config was rejected"), 'Site-wide Javascript');
	    });
	  });
	};
	var resolveAndCleanValue = function resolveAndCleanValue(value, key) {
	  try {
	    setCurrentSitemapKey(key);
	    if (_typeof(value) === "object" && !Array.isArray(value) && Object.keys(value).length > 0) {
	      return buildNestedAttributes(value);
	    } else {
	      return Promise.resolve(value).then(function (resolvedNotNestedValue) {
	        return typeof resolvedNotNestedValue === "function" ? resolvedNotNestedValue() : resolvedNotNestedValue;
	      });
	    }
	  } catch (e) {
	    Signals.onFireException.emit(new Error("getValue for ".concat(key, " failed on ").concat(sitemapState.result.matchedConfig.name, " while evaluating custom function. ").concat(e.message, ".")), 'Site-wide Javascript');
	  }
	};
	var buildNestedAttributes = function buildNestedAttributes(nestedAttributeConfig) {
	  var nestedAttributes = {};
	  var nestedAttributeKeys = Object.keys(nestedAttributeConfig);
	  var resolvedNestedAttributes = {};
	  nestedAttributeKeys.forEach(function (nestedKey) {
	    var nestedAttributeValue = nestedAttributeConfig[nestedKey];
	    var resolvedNestedAttributeValue = resolveAndCleanValue(nestedAttributeValue, nestedKey);
	    nestedAttributes[nestedKey] = resolvedNestedAttributeValue;
	  });
	  return Promise.all(Object.values(nestedAttributes)).then(function (values) {
	    values.forEach(function (value, index) {
	      var key = nestedAttributeKeys[index];
	      resolvedNestedAttributes[key] = value;
	    });
	    return resolvedNestedAttributes;
	  });
	};

	var listenerSearchInterval;
	var startListenerSearch = function startListenerSearch() {
	  cancelListenerSearch();
	  if (pageHasMissingListeners()) {
	    listenerSearchInterval = setInterval(function () {
	      var updated = false;
	      var intervalTimerStart = new Date().getTime();
	      var listenerState = sitemapState.result.matchedConfig.listeners.map(function (d) {
	        if (d.selectorFound) {
	          return d;
	        } else {
	          var listener = attemptToBindListener(d);
	          updated = listener.selectorFound || updated;
	          return listener;
	        }
	      });
	      if (updated) {
	        Object.assign(sitemapState.result.matchedConfig, _objectSpread2(_objectSpread2({}, sitemapState.result.matchedConfig), {}, {
	          listeners: listenerState
	        }));
	      }
	      var intervalTimerEnd = new Date().getTime();
	      var intervalRunningTime = intervalTimerEnd - intervalTimerStart;
	      if (intervalRunningTime > 50 || !pageHasMissingListeners()) {
	        cancelListenerSearch();
	      }
	    }, 1000);
	  }
	};
	var pageHasMissingListeners = function pageHasMissingListeners() {
	  if (sitemapState.result.matchedConfig) {
	    var listeners = sitemapState.result.matchedConfig.listeners;
	    if (listeners) {
	      return listeners.filter(function (d) {
	        return !d.selectorFound;
	      }).length;
	    } else {
	      return false;
	    }
	  } else {
	    return false;
	  }
	};
	var cancelListenerSearch = function cancelListenerSearch() {
	  if (typeof listenerSearchInterval === 'number') {
	    clearInterval(listenerSearchInterval);
	  }
	  listenerSearchInterval = null;
	};
	var sendEventWithCallback = function sendEventWithCallback(event, listener) {
	  try {
	    listener.callback(event);
	  } catch (e) {
	    Signals.onFireException.emit(new Error("Listener callback on ".concat(listener.bind, " bound to ").concat(listener.selector, " failed for the ").concat(sitemapState.result.matchedConfig.name, " page config. ").concat(e.message, ".")), 'Site-wide Javascript');
	  }
	};
	var attemptToBindListener = function attemptToBindListener(listenerConfig) {
	  var elements = cash(listenerConfig.selector);
	  var listener = _objectSpread2(_objectSpread2({}, listenerConfig), {}, {
	    selectorFound: elements.length > 0
	  });
	  elements.on(listener.bind, function (event) {
	    sendEventWithCallback(event, listener);
	  });
	  return listener;
	};
	var removeCurrentListeners = function removeCurrentListeners() {
	  if (sitemapState.result && sitemapState.result.matchedConfig && sitemapState.result.matchedConfig.listeners) {
	    sitemapState.result.matchedConfig.listeners.forEach(function (listener) {
	      cash(listener.selector).off(listener.bind);
	    });
	  }
	};

	var setConfig = function setConfig(config) {
	  config.global = config.global || {};
	  if (_typeof(config.global) != "object") {
	    Signals.onFireException.emit(new Error("The global config has a type of ".concat(_typeof(config.global), ", but it must be an object")), 'Sitewide Javascript');
	  }
	  Object.assign(sitemapState.config, _objectSpread2({}, config));
	  Signals.onInitSitemap.emit(sitemapState.config);
	};
	var initSitemap = function initSitemap(siteMapConfig) {
	  run(siteMapConfig);
	  return true;
	};
	var build = function build(config) {
	  matchPageConfig(config.pageTypes).then(mergeConfigWithGlobal).then(handleConfig).catch(function (e) {
	    if (e !== SITEMAP_REINIT) Signals.onFireException.emit(new Error("Unhandled exception: ".concat(e)), 'Site-wide Javascript');
	  });
	};
	var handleConfig = function handleConfig(pageConfig) {
	  sitemapState.result.matchedConfig = _objectSpread2(_objectSpread2({}, pageConfig), {}, {
	    listeners: processListeners(pageConfig)
	  });
	  sitemapState.result.currentPage = _objectSpread2(_objectSpread2({}, sitemapState.result.currentPage || {}), {}, {
	    source: {
	      pageType: pageConfig.name,
	      locale: processLocale(pageConfig)
	    },
	    user: {
	      anonymousId: null // TODO: this gets filled in during sendEvent, a little strange
	    },

	    interaction: null,
	    pageView: true
	  });
	  return pageConfig.interaction ? processInteraction(pageConfig).then(function (interaction) {
	    sitemapState.result.currentPage.interaction = interaction;
	  }) : Promise.resolve();
	};
	var processListeners = function processListeners(pageConfig) {
	  return (pageConfig.listeners || []).map(function (listenerConfig) {
	    return attemptToBindListener(listenerConfig);
	  });
	};
	var processLocale = function processLocale(pageConfig) {
	  return typeof pageConfig.locale === "function" ? pageConfig.locale() : pageConfig.locale;
	};
	var mergeDeep = function mergeDeep() {
	  var isObject = function isObject(obj) {
	    return obj && _typeof(obj) === 'object';
	  };
	  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
	    objects[_key] = arguments[_key];
	  }
	  return objects.reduce(function (prev, obj) {
	    Object.keys(obj).forEach(function (key) {
	      var pVal = prev[key];
	      var oVal = obj[key];
	      if (Array.isArray(pVal) && Array.isArray(oVal)) {
	        Object.assign(prev, _defineProperty({}, key, pVal.concat.apply(pVal, _toConsumableArray(oVal))));
	      } else if (isObject(pVal) && isObject(oVal)) {
	        Object.assign(prev, _defineProperty({}, key, mergeDeep(pVal, oVal)));
	      } else {
	        Object.assign(prev, _defineProperty({}, key, oVal));
	      }
	    });
	    return prev;
	  }, {});
	};
	var mergeConfigWithGlobal = function mergeConfigWithGlobal(pageConfig) {
	  var global = sitemapState.config.global || {};
	  var globalOnActionEvent = global.onActionEvent;
	  delete global.onActionEvent;
	  var mergedConfig = mergeDeep(global, pageConfig);
	  global.onActionEvent = globalOnActionEvent;
	  return mergedConfig;
	};
	var validatePageConfigs = function validatePageConfigs(siteMapConfig) {
	  try {
	    validatePageTypeConfigs(siteMapConfig.pageTypes);
	    return true;
	  } catch (e) {
	    Signals.onFireException.emit(new Error(e), 'Sitemap');
	    return false;
	  }
	};
	var validatePageTypeConfigs = function validatePageTypeConfigs(pageConfigs) {
	  pageConfigs.forEach(function (pageConfig) {
	    if (!pageConfig.name || !pageConfig.isMatch) {
	      throw new Error("All page configs must have a name and isMatch attribute defined");
	    }
	  });
	};
	var processResult = function processResult() {
	  var result = sitemapState.result;
	  sendEvent(sitemapState.result.currentPage);
	  sitemapState.result = result;
	};
	var run = function run(siteMapConfig) {
	  setConfig(siteMapConfig);
	  removeCurrentListeners();
	  removeOutstandingPageMatchResolvers();
	  cancelListenerSearch();
	  sitemapState.result.currentPage = null;
	  if (!validatePageConfigs(siteMapConfig)) {
	    return;
	  }
	  matchPageConfig(siteMapConfig.pageTypes).then(mergeConfigWithGlobal).then(handleConfig).then(processResult).then(startListenerSearch).catch(function (e) {
	    if (e !== SITEMAP_REINIT) Signals.onFireException.emit(new Error("Unhandled exception: ".concat(e)), 'Site-wide Javascript');
	  });
	};

	function listener(bind, selector, callback) {
	  if (typeof callback === "function") {
	    return {
	      bind: bind,
	      selector: selector,
	      callback: callback
	    };
	  } else {
	    return null;
	  }
	}

	var fromSelector = function fromSelector(selector, transform) {
	  return function () {
	    if (typeof selector != 'string') {
	      Signals.onFireException.emit(new Error("getValue for ".concat(getCurrentSitemapKey(), " failed on ").concat(sitemapState.result.matchedConfig.name, ". Selector must be a string.")), 'Site-wide Javascript');
	      return null;
	    }
	    var resolvedValue = cash(selector).first().text();
	    resolvedValue = internalTransform(transform, resolvedValue);
	    return resolvedValue;
	  };
	};
	var fromSelectorAttribute = function fromSelectorAttribute(selector, attribute, transform) {
	  return function () {
	    if (typeof selector != 'string') {
	      Signals.onFireException.emit(new Error("getValue for ".concat(getCurrentSitemapKey(), " failed on ").concat(sitemapState.result.matchedConfig.name, ". Selector must be a string.")), 'Site-wide Javascript');
	      return null;
	    }
	    if (typeof attribute != 'string') {
	      Signals.onFireException.emit(new Error("getValue for ".concat(getCurrentSitemapKey(), " failed on ").concat(sitemapState.result.matchedConfig.name, ". Attribute must be a string.")), 'Site-wide Javascript');
	      return null;
	    }
	    var resolvedValue = cash(selector).first().attr(attribute);
	    resolvedValue = internalTransform(transform, resolvedValue);
	    return resolvedValue;
	  };
	};
	var fromSelectorMultiple = function fromSelectorMultiple(selector, transform) {
	  return function () {
	    if (typeof selector != 'string') {
	      Signals.onFireException.emit(new Error("getValue for ".concat(getCurrentSitemapKey(), " failed on ").concat(sitemapState.result.matchedConfig.name, ". Selector must be a string.")), 'Site-wide Javascript');
	      return null;
	    }
	    var selectedElements = cash(selector);
	    var resolvedValue = selectedElements.get().map(function (elem) {
	      return cash(elem).text();
	    });
	    resolvedValue = internalTransform(transform, resolvedValue);
	    return resolvedValue;
	  };
	};
	var fromSelectorAttributeMultiple = function fromSelectorAttributeMultiple(selector, attribute, transform) {
	  return function () {
	    if (typeof selector != 'string') {
	      Signals.onFireException.emit(new Error("getValue for ".concat(getCurrentSitemapKey(), " failed on ").concat(sitemapState.result.matchedConfig.name, ". Selector must be a string.")), 'Site-wide Javascript');
	      return null;
	    }
	    if (typeof attribute != 'string') {
	      Signals.onFireException.emit(new Error("getValue for ".concat(getCurrentSitemapKey(), " failed on ").concat(sitemapState.result.matchedConfig.name, ". Attribute must be a string.")), 'Site-wide Javascript');
	      return null;
	    }
	    var selectedElements = cash(selector);
	    var resolvedValue = selectedElements.get().map(function (elem) {
	      return cash(elem).attr(attribute);
	    });
	    resolvedValue = internalTransform(transform, resolvedValue);
	    return resolvedValue;
	  };
	};
	var fromItemProp = function fromItemProp(itemProp, transform) {
	  return function () {
	    var resolvedValue = cash("[itemprop='" + itemProp + "']").first().attr("content");
	    resolvedValue = internalTransform(transform, resolvedValue);
	    return resolvedValue;
	  };
	};
	var fromMeta = function fromMeta(metaTag, transform) {
	  return function () {
	    var resolvedValue = cash("meta[name='" + metaTag + "']").first().attr("content") || cash("meta[property='" + metaTag + "']").first().attr("content");
	    resolvedValue = internalTransform(transform, resolvedValue);
	    return resolvedValue;
	  };
	};
	var fromWindow = function fromWindow(path, transform) {
	  return function () {
	    var resolvedValue = getValueFromNestedObject(path);
	    resolvedValue = internalTransform(transform, resolvedValue);
	    return resolvedValue;
	  };
	};
	var fromJsonLd = function fromJsonLd(path, transform) {
	  return function () {
	    var json = cash("script[type='application/ld+json']").first().text();
	    try {
	      var parsedJson = JSON.parse(json);
	      if (!path) {
	        return internalTransform(transform, parsedJson);
	      } else {
	        var resolvedValue = getValueFromNestedObject(path, parsedJson);
	        return internalTransform(transform, resolvedValue);
	      }
	    } catch (e) {
	      Signals.onFireException.emit(new Error("Parsing JSON-LD for ".concat(getCurrentSitemapKey(), " failed on ").concat(sitemapState.result.matchedConfig.name, ". ").concat(e)), 'Site-wide Javascript');
	    }
	  };
	};
	var fromCanonical = function fromCanonical(transform) {
	  return function () {
	    var resolvedValue = cash('link[rel=canonical]').attr("href");
	    resolvedValue = internalTransform(transform, resolvedValue);
	    return resolvedValue;
	  };
	};
	var fromHref = function fromHref(transform) {
	  return function () {
	    var resolvedValue = window.location.href;
	    resolvedValue = internalTransform(transform, resolvedValue);
	    return resolvedValue;
	  };
	};
	var buildCategoryId = function buildCategoryId(selector, startFrom, ignoreLast, transform) {
	  return function () {
	    var elements = Array.from(cash(selector));
	    if (startFrom) {
	      elements = elements.slice(startFrom);
	    }
	    if (ignoreLast) {
	      elements = elements.slice(0, -1);
	    }
	    var idParts = [];
	    elements.forEach(function (elem) {
	      var idPart = cash(elem).text().trim();
	      if (idPart) {
	        idParts.push(idPart);
	      } else {
	        Signals.onFireException.emit(new Error("buildCategoryId for ".concat(getCurrentSitemapKey(), " failed on ").concat(sitemapState.result.matchedConfig.name, ". A category part is null.")), 'Site-wide Javascript');
	      }
	    });
	    var categoryId = idParts.join('|');
	    categoryId = internalTransform(transform, categoryId);
	    return categoryId;
	  };
	};
	var buildCategoryIdAttribute = function buildCategoryIdAttribute(selector, attribute, startFrom, ignoreLast, transform) {
	  return function () {
	    var elements = Array.from(cash(selector));
	    if (startFrom) {
	      elements = elements.slice(startFrom);
	    }
	    if (ignoreLast) {
	      elements = elements.slice(0, -1);
	    }
	    var idParts = [];
	    elements.forEach(function (elem) {
	      var idPart = cash(elem).attr(attribute).trim();
	      if (idPart) {
	        idParts.push(idPart);
	      } else {
	        Signals.onFireException.emit(new Error("buildCategoryId for ".concat(getCurrentSitemapKey(), " failed on ").concat(sitemapState.result.matchedConfig.name, ". A category part is null.")), 'Site-wide Javascript');
	      }
	    });
	    var categoryId = idParts.join('|');
	    categoryId = internalTransform(transform, categoryId);
	    return categoryId;
	  };
	};
	var internalTransform = function internalTransform(transformFunc, resolvedValue) {
	  if (transformFunc) {
	    try {
	      return transformFunc(resolvedValue);
	    } catch (e) {
	      Signals.onFireException.emit(new Error("getValue for ".concat(getCurrentSitemapKey(), " failed on ").concat(sitemapState.result.matchedConfig.name, " inside of the custom transform function. ").concat(e)), 'Site-wide Javascript');
	      return null;
	    }
	  }
	  return resolvedValue;
	};
	var getValueFromNestedObject = function getValueFromNestedObject(path, obj) {
	  var cur = obj || window;
	  var elems = path.split('.');
	  var match;
	  var _iterator = _createForOfIteratorHelper(elems),
	    _step;
	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      var elem = _step.value;
	      match = /(\w+)\[([0-9]+)\]/.exec(elem);
	      if (cur[elem]) {
	        cur = cur[elem];
	      } else if (match) {
	        if (cur[match[1]]) {
	          cur = cur[match[1]][parseInt(match[2], 10)];
	          if (!cur) {
	            return null;
	          }
	        }
	      } else {
	        return null;
	      }
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }
	  return cur;
	};
	var resolvers = {
	  fromSelector: fromSelector,
	  fromSelectorAttribute: fromSelectorAttribute,
	  fromSelectorMultiple: fromSelectorMultiple,
	  fromSelectorAttributeMultiple: fromSelectorAttributeMultiple,
	  fromItemProp: fromItemProp,
	  fromMeta: fromMeta,
	  fromWindow: fromWindow,
	  fromJsonLd: fromJsonLd,
	  fromCanonical: fromCanonical,
	  fromHref: fromHref,
	  buildCategoryId: buildCategoryId,
	  buildCategoryIdAttribute: buildCategoryIdAttribute
	};

	// tslint:disable variable-name
	var cashDom = cash;

	var unbindByIds = {};
	var bind = function bind(trueFunc) {
	  var bindId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.random().toString(36).slice(2);
	  var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2000;
	  var checkInterval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
	  if (typeof trueFunc !== "function") return;
	  return new Promise(function (resolve, reject) {
	    var currentRunTime = 0;
	    var interval = setInterval(function () {
	      try {
	        currentRunTime += checkInterval;
	        var resolvedValue = trueFunc();
	        if (resolvedValue) {
	          unbind(bindId);
	          resolve(resolvedValue);
	        } else if (currentRunTime >= timeout) {
	          unbind(bindId);
	          resolve(false);
	        }
	      } catch (e) {
	        unbind(bindId);
	        reject(e);
	      }
	    }, checkInterval);
	    unbindByIds[bindId] = function () {
	      clearInterval(interval);
	    };
	  });
	};
	var unbind = function unbind(bindId) {
	  if (!bindId || typeof bindId !== "string" || typeof unbindByIds[bindId] !== "function") return null;
	  unbindByIds[bindId]();
	  delete unbindByIds[bindId];
	};
	var getBindings = function getBindings() {
	  return unbindByIds;
	};
	var clearBindings = function clearBindings() {
	  for (var id in unbindByIds) {
	    if (unbindByIds.hasOwnProperty(id) && typeof unbindByIds[id] === "function") {
	      unbind(id);
	    }
	  }
	};
	var resolveWhenTrue = {
	  bind: bind,
	  unbind: unbind,
	  getBindings: getBindings,
	  clearBindings: clearBindings
	};

	var util = {
	  resolveWhenTrue: resolveWhenTrue
	};

	var lifecycle = {
	  state: "shutDown" /* SHUT_DOWN */
	};

	var getLifecycleState = function getLifecycleState() {
	  return lifecycle.state;
	};
	var setLifecycleState = function setLifecycleState(state) {
	  return lifecycle.state = state;
	};

	var sdkConfig = {
	  cookieDomain: null,
	  consents: null
	};
	var getSdkConfig = function getSdkConfig() {
	  return sdkConfig;
	};
	var setSdkConfig = function setSdkConfig(newSdkConfig) {
	  if (newSdkConfig.cookieDomain) {
	    // TODO: change this maybe to event dispatch/listener
	    setCookieDomain(newSdkConfig.cookieDomain);
	  }
	  setCookieHash();
	  sdkConfig = _objectSpread2(_objectSpread2({}, sdkConfig), newSdkConfig);
	};

	var DisplayUtils = function () {
	  var unbindByIds = {};
	  function generateId() {
	    var id = Math.random().toString(36).slice(2);
	    while (unbindByIds[id]) {
	      id = Math.random().toString(36).slice(2);
	    }
	    return id;
	  }
	  function getBindId(providedId, defaultId, useRandomId) {
	    return useRandomId ? generateId() : providedId || defaultId;
	  }
	  function buildBaseMethods(bindId, useRandomId) {
	    return {
	      pageElementLoaded: function pageElementLoaded(targetSelector, observerSelector) {
	        if (typeof observerSelector !== "string" || observerSelector === "") {
	          observerSelector = cashDom("body").length > 0 ? "body" : "html";
	        }
	        if (typeof targetSelector !== "string" || targetSelector === "") {
	          throw new Error("[pageElementLoaded] Invalid arguments");
	        }
	        return new Promise(function (resolve) {
	          var targetElements = cashDom(targetSelector);
	          if (targetElements.length > 0) {
	            resolve(targetElements[0]);
	          } else {
	            var observerNode = cashDom(observerSelector)[0];
	            if (!observerNode) {
	              throw new Error("pageElementLoaded cannot be bound. observerSelector ".concat(observerSelector, " is not on the page"));
	            }
	            var observer = new MutationObserver(function (mutationList, observer) {
	              var _iterator = _createForOfIteratorHelper(mutationList),
	                _step;
	              try {
	                for (_iterator.s(); !(_step = _iterator.n()).done;) {
	                  var mutationRecord = _step.value;
	                  if (mutationRecord.addedNodes && mutationRecord.addedNodes.length > 0) {
	                    var _iterator2 = _createForOfIteratorHelper(mutationRecord.addedNodes),
	                      _step2;
	                    try {
	                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	                        var addedNode = _step2.value;
	                        var targetElement = cashDom(addedNode).is(targetSelector) ? addedNode : cashDom(addedNode).find(targetSelector).get(0);
	                        if (targetElement) {
	                          if (bindId) {
	                            bindingMethods.unbind(bindId);
	                          } else {
	                            observer.disconnect();
	                          }
	                          resolve(targetElement);
	                          return;
	                        }
	                      }
	                    } catch (err) {
	                      _iterator2.e(err);
	                    } finally {
	                      _iterator2.f();
	                    }
	                  }
	                }
	              } catch (err) {
	                _iterator.e(err);
	              } finally {
	                _iterator.f();
	              }
	            });
	            observer.observe(observerNode, {
	              childList: true,
	              subtree: true
	            });
	          }
	          bindId = getBindId(bindId, "<pageElementLoaded>" + targetSelector, useRandomId);
	          unbindByIds[bindId] = function () {
	            observer && observer.disconnect();
	          };
	        });
	      },
	      pageElementVisible: function pageElementVisible(selector, percentage) {
	        var threshold = percentage || 0;
	        if (typeof selector !== "string" || selector === "" || typeof threshold !== "number" || threshold < 0 || threshold > 1) {
	          throw new Error("[pageElementVisible] Invalid arguments");
	        }
	        return new Promise(function (resolve) {
	          var target = cashDom(selector);
	          var options = {
	            threshold: threshold
	          };
	          var observer = new IntersectionObserver(callbackFn, options);
	          function callbackFn(entries, observer) {
	            for (var i = 0; i < entries.length; i++) {
	              if (entries[i].isIntersecting) {
	                if (bindId) {
	                  bindingMethods.unbind(bindId);
	                } else {
	                  observer.disconnect();
	                }
	                resolve(entries[i]);
	                break;
	              }
	            }
	          }
	          observer.observe(target[0]);
	          bindId = getBindId(bindId, "<pageElementVisible>" + selector, useRandomId);
	          unbindByIds[bindId] = function () {
	            observer.disconnect();
	          };
	        });
	      },
	      pageExit: function pageExit(delay) {
	        delay = delay || 0;
	        if (typeof delay !== "number" || delay < 0) {
	          throw new Error("[pageExit] Invalid arguments");
	        }
	        return new Promise(function (resolve) {
	          var $target = cashDom(document);
	          var events = "mousemove";
	          var timer;
	          function onmousemove(e) {
	            clearTimeout(timer);
	            if (e.pageY - window.pageYOffset <= 10) {
	              timer = delay > 0 ? setTimeout(callbackFn.bind(this, e), delay) : callbackFn.call(this, e);
	            }
	          }
	          function callbackFn(e) {
	            if (bindId) {
	              bindingMethods.unbind(bindId);
	            } else {
	              $target.off(events, onmousemove);
	            }
	            clearTimeout(timer);
	            resolve(e);
	          }
	          $target.on(events, onmousemove);
	          bindId = getBindId(bindId, "<pageExit>", useRandomId);
	          unbindByIds[bindId] = function () {
	            $target.off(events, onmousemove);
	          };
	        });
	      },
	      pageInactive: function pageInactive(ms) {
	        if (typeof ms !== "number" || ms <= 0) {
	          throw new Error("[pageInactive] Invalid arguments");
	        }
	        function _pageInactive(ms, state) {
	          var promise = new Promise(function (resolve) {
	            var $target = cashDom(document);
	            var resetEvents = "mousemove click scroll keyup keydown";
	            var idleTimer;
	            function callbackFn(e) {
	              e = e || new Event("pageInactive");
	              if (bindId && !state.isSubscribe) {
	                bindingMethods.unbind(bindId);
	              } else {
	                $target.off(resetEvents, resetTimer);
	              }
	              resolve(e);
	            }
	            function resetTimer(e) {
	              clearTimeout(idleTimer);
	              idleTimer = setTimeout(callbackFn.bind(this, e), ms);
	            }
	            resetTimer();
	            $target.on(resetEvents, resetTimer);
	          });
	          promise.subscribe = function subscribe(callback) {
	            delete promise.subscribe;
	            state.isSubscribe = true;
	            promise.then(function (event) {
	              event.disconnect = function () {
	                if (bindId) {
	                  bindingMethods.unbind(bindId);
	                } else {
	                  state.isDisconnected = true;
	                }
	              };
	              callback(event);
	              !state.isDisconnected && _pageInactive(ms, state).subscribe(callback);
	            });
	            return promise;
	          };
	          return promise;
	        }
	        var state = {
	          isDisconnected: false,
	          isSubscribe: false
	        };
	        bindId = getBindId(bindId, "<pageInactive>", useRandomId);
	        unbindByIds[bindId] = function () {
	          state.isDisconnected = true;
	        };
	        return _pageInactive(ms, state);
	      },
	      pageScroll: function pageScroll(percentage) {
	        if (typeof percentage !== "number" || percentage < 0 || percentage > 1) {
	          throw new Error("[pageScroll] Invalid arguments");
	        }
	        return new Promise(function (resolve) {
	          var $target = cashDom(document);
	          var events = "scroll";
	          function callbackFn(e) {
	            resolve(e);
	            if (bindId) {
	              bindingMethods.unbind(bindId);
	            } else {
	              $target.off(events, onScroll);
	            }
	          }
	          function onScroll(e) {
	            var scrollPercentage = window.scrollY / (document.documentElement.scrollHeight - window.innerHeight);
	            if (scrollPercentage >= percentage) {
	              callbackFn.call(this, e);
	            }
	          }
	          $target.on(events, onScroll);
	          bindId = getBindId(bindId, "<pageScroll>", useRandomId);
	          unbindByIds[bindId] = function () {
	            $target.off(events, onScroll);
	          };
	        });
	      }
	    };
	  }
	  function buildBindingMethods() {
	    return {
	      bind: function bind(id) {
	        if (id && unbindByIds[id]) {
	          unbindByIds[id]();
	          delete unbindByIds[id];
	        }
	        return buildBaseMethods(id);
	      },
	      unbind: function unbind(id) {
	        if (!id || typeof id !== "string" || typeof unbindByIds[id] !== "function") return null;
	        unbindByIds[id]();
	        delete unbindByIds[id];
	      },
	      getBindings: function getBindings() {
	        return unbindByIds;
	      },
	      clearBindings: function clearBindings() {
	        for (var id in unbindByIds) {
	          if (unbindByIds.hasOwnProperty(id)) {
	            unbindByIds[id]();
	            delete unbindByIds[id];
	          }
	        }
	      }
	    };
	  }
	  var baseMethods = buildBaseMethods(null, true);
	  var bindingMethods = buildBindingMethods();
	  return Object.assign(baseMethods, bindingMethods);
	}();

	var unbindOnFireException;
	var unbindOnSendEvent;
	var unbindOnPageMatchStatusUpdated;
	var unbindOnInitSitemap;
	function unbindPublicSignalsToDocument() {
	  if (unbindOnFireException) {
	    unbindOnFireException();
	  }
	  if (unbindOnSendEvent) {
	    unbindOnSendEvent();
	  }
	  if (unbindOnPageMatchStatusUpdated) {
	    unbindOnPageMatchStatusUpdated();
	  }
	  if (unbindOnInitSitemap) {
	    unbindOnInitSitemap();
	  }
	}
	function bindPublicSignalsToDocument() {
	  unbindOnFireException = Signals.onFireException.on(function (error, context) {
	    document.dispatchEvent(new CustomEvent(CustomEvents.OnException, {
	      detail: {
	        error: error,
	        context: context
	      }
	    }));
	  });
	  unbindOnSendEvent = Signals.onEventSend.on(function (actionEvent) {
	    var canceled = !document.dispatchEvent(new CustomEvent(CustomEvents.OnBeforeEventSend, {
	      detail: {
	        actionEvent: actionEvent
	      },
	      cancelable: true
	    }));
	    if (!canceled) {
	      document.dispatchEvent(new CustomEvent(CustomEvents.OnEventSend, {
	        detail: {
	          actionEvent: actionEvent
	        }
	      }));
	    }
	  });
	  unbindOnPageMatchStatusUpdated = Signals.onPageMatchStatusUpdated.on(function (matchStatus) {
	    document.dispatchEvent(new CustomEvent(CustomEvents.OnPageMatchStatusUpdated, {
	      detail: {
	        matchStatus: matchStatus
	      }
	    }));
	  });
	  unbindOnInitSitemap = Signals.onInitSitemap.on(function (sitemapConfig) {
	    document.dispatchEvent(new CustomEvent(CustomEvents.OnInitSitemap, {
	      detail: {
	        sitemapConfig: sitemapConfig
	      }
	    }));
	  });
	}
	function checkEnv() {
	  if (userAgentIsRobot()) {
	    return shutDown('You are a robot.');
	  }
	  // Casting visibilityState to avoid complaints about 'prerender' no longer being a valid VisibilityState value
	  // in TypeScript 3.7.  Some browsers might still return this, even though it's deprecated.
	  var preRendered = document.visibilityState === 'prerender';
	  if (preRendered && isSafari) {
	    return shutDown('Page is pre-rendered and loaded in Safari.');
	  }
	  return true;
	}
	function shutDown(message) {
	  unbindPublicSignalsToDocument();
	  document.dispatchEvent(new CustomEvent(CustomEvents.OnShutDown, {
	    detail: {
	      message: message
	    }
	  }));
	  setLifecycleState("shutDown" /* SHUT_DOWN */);
	  return false;
	}
	// returns a Promise that is resolved or rejected based on initialization of the Web SDK itself
	// and not around validating anything around consent
	var init = function init() {
	  var sdkConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  if (!checkEnv()) {
	    return Promise.reject();
	  }
	  if (getLifecycleState() == "initialized" /* INITIALIZED */) {
	    shutDown("reinitializing Web SDK");
	  }
	  setSdkConfig(sdkConfig);
	  // DO NOT DOCUMENT FOLLOWING DISPATCH EVENT - TEMPORARY WORKAROUND!
	  document.dispatchEvent(new CustomEvent(CustomEvents.OnBeforeInit));
	  bindPublicSignalsToDocument();
	  loadAnonymousIdentity();
	  setLifecycleState("initialized" /* INITIALIZED */);
	  document.dispatchEvent(new CustomEvent(CustomEvents.OnInit, {
	    detail: {
	      sdkConfig: getSdkConfig()
	    }
	  }));
	  resolveConsents(sdkConfig.consents);
	  return Promise.resolve();
	};
	var reinit = function reinit() {
	  // W-9974392: don't restore the initial configured consent because it may have changed, use the actual values instead
	  var consents = getConsents().map(function (consentWithMetadata) {
	    return consentWithMetadata.consent;
	  });
	  init(_objectSpread2(_objectSpread2({}, getSdkConfig()), {}, {
	    consents: consents
	  })).then(function () {
	    initSitemap(sitemapState.config);
	  });
	};
	// TODO: is there a better way to do this? We need to export as an ES module but also expose
	// something on the global namespace.
	window.SalesforceInteractions = {
	  init: init,
	  reinit: reinit,
	  sendEvent: sendEvent,
	  sendException: sendException,
	  getAnonymousId: getAnonymousId,
	  setAnonymousId: setAnonymousId,
	  getCookieDomain: getCookieDomain,
	  setCookieDomain: setCookieDomain,
	  updateConsents: updateConsents,
	  getConsents: getConsents,
	  ConsentStatus: ConsentStatus,
	  log: Logger,
	  getLoggingLevel: getLoggingLevel,
	  setLoggingLevel: setLoggingLevel,
	  initSitemap: initSitemap,
	  getSitemapConfig: getSitemapConfig,
	  getSitemapResult: getSitemapResult,
	  CatalogObjectInteractionName: CatalogObjectInteractionName,
	  CartInteractionName: CartInteractionName,
	  OrderInteractionName: OrderInteractionName,
	  listener: listener,
	  build: build,
	  cashDom: cashDom,
	  resolvers: resolvers,
	  util: util,
	  DisplayUtils: DisplayUtils,
	  CustomEvents: CustomEvents,
	  setSecureAttributeOnCookie: setSecureAttributeOnCookie
	};

	const DATA_PROVIDER_TYPE_PAGE = 'page';
	const DATA_PROVIDER_TYPE_USER = 'user';
	const DATA_PROVIDER_TYPE_CATALOG = 'catalog';
	const DATA_PROVIDER_TYPE_CART = 'cart';
	const DATA_PROVIDER_TYPE_SITE = 'site';
	const DATA_PROVIDER_TYPE_RECOMMENDATION = 'recommendation';
	const DATA_PROVIDER_TYPE_SEARCH_RESULT = 'searchResult';
	const CONTEXTUAL_DATA_PROVIDER_TYPES = ['page', 'site', 'user'];
	const EVENT_SET_GUEST_GUID = 'set-guest-uuid';
	const EVENT_SET_PAGE_VIEW = 'page-view';
	const EVENT_USER_ENGAGEMENT = 'user-engagement';
	const EVENT_CATALOG_OBJECT_VIEW_START = 'catalog-object-view-start';
	const EVENT_CATALOG_OBJECT_VIEW_STOP = 'catalog-object-view-stop';
	const EVENT_CATALOG_OBJECT_CLICK = 'catalog-object-click';
	const EVENT_CART_ADD = 'cart-add';
	const EVENT_CART_REMOVE = 'cart-remove';
	const EVENT_CART_REPLACE = 'cart-replace';
	const EVENT_SEARCH = 'search';
	const EVENT_ANCHOR_CLICK = 'anchor-click';
	const EVENT_BUTTON_CLICK = 'button-click';
	const EVENT_PAGE_SCROLL_TO_BOTTOM = 'page-scroll-to-bottom';
	const CATALOG_OBJECT_TYPE_PRODUCT = 'Product';
	const DLO_USER_ENGAGEMENT = 'userEngagement';

	var uaParser = {exports: {}};

	(function (module, exports) {
		/////////////////////////////////////////////////////////////////////////////////
		/* UAParser.js v1.0.35
		   Copyright © 2012-2021 Faisal Salman <f@faisalman.com>
		   MIT License *//*
		   Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
		   Supports browser & node.js environment. 
		   Demo   : https://faisalman.github.io/ua-parser-js
		   Source : https://github.com/faisalman/ua-parser-js */
		/////////////////////////////////////////////////////////////////////////////////

		(function (window, undefined$1) {

		    //////////////
		    // Constants
		    /////////////


		    var LIBVERSION  = '1.0.35',
		        EMPTY       = '',
		        UNKNOWN     = '?',
		        FUNC_TYPE   = 'function',
		        UNDEF_TYPE  = 'undefined',
		        OBJ_TYPE    = 'object',
		        STR_TYPE    = 'string',
		        MAJOR       = 'major',
		        MODEL       = 'model',
		        NAME        = 'name',
		        TYPE        = 'type',
		        VENDOR      = 'vendor',
		        VERSION     = 'version',
		        ARCHITECTURE= 'architecture',
		        CONSOLE     = 'console',
		        MOBILE      = 'mobile',
		        TABLET      = 'tablet',
		        SMARTTV     = 'smarttv',
		        WEARABLE    = 'wearable',
		        EMBEDDED    = 'embedded',
		        UA_MAX_LENGTH = 350;

		    var AMAZON  = 'Amazon',
		        APPLE   = 'Apple',
		        ASUS    = 'ASUS',
		        BLACKBERRY = 'BlackBerry',
		        BROWSER = 'Browser',
		        CHROME  = 'Chrome',
		        EDGE    = 'Edge',
		        FIREFOX = 'Firefox',
		        GOOGLE  = 'Google',
		        HUAWEI  = 'Huawei',
		        LG      = 'LG',
		        MICROSOFT = 'Microsoft',
		        MOTOROLA  = 'Motorola',
		        OPERA   = 'Opera',
		        SAMSUNG = 'Samsung',
		        SHARP   = 'Sharp',
		        SONY    = 'Sony',
		        XIAOMI  = 'Xiaomi',
		        ZEBRA   = 'Zebra',
		        FACEBOOK    = 'Facebook',
		        CHROMIUM_OS = 'Chromium OS',
		        MAC_OS  = 'Mac OS';

		    ///////////
		    // Helper
		    //////////

		    var extend = function (regexes, extensions) {
		            var mergedRegexes = {};
		            for (var i in regexes) {
		                if (extensions[i] && extensions[i].length % 2 === 0) {
		                    mergedRegexes[i] = extensions[i].concat(regexes[i]);
		                } else {
		                    mergedRegexes[i] = regexes[i];
		                }
		            }
		            return mergedRegexes;
		        },
		        enumerize = function (arr) {
		            var enums = {};
		            for (var i=0; i<arr.length; i++) {
		                enums[arr[i].toUpperCase()] = arr[i];
		            }
		            return enums;
		        },
		        has = function (str1, str2) {
		            return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
		        },
		        lowerize = function (str) {
		            return str.toLowerCase();
		        },
		        majorize = function (version) {
		            return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split('.')[0] : undefined$1;
		        },
		        trim = function (str, len) {
		            if (typeof(str) === STR_TYPE) {
		                str = str.replace(/^\s\s*/, EMPTY);
		                return typeof(len) === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
		            }
		    };

		    ///////////////
		    // Map helper
		    //////////////

		    var rgxMapper = function (ua, arrays) {

		            var i = 0, j, k, p, q, matches, match;

		            // loop through all regexes maps
		            while (i < arrays.length && !matches) {

		                var regex = arrays[i],       // even sequence (0,2,4,..)
		                    props = arrays[i + 1];   // odd sequence (1,3,5,..)
		                j = k = 0;

		                // try matching uastring with regexes
		                while (j < regex.length && !matches) {

		                    if (!regex[j]) { break; }
		                    matches = regex[j++].exec(ua);

		                    if (!!matches) {
		                        for (p = 0; p < props.length; p++) {
		                            match = matches[++k];
		                            q = props[p];
		                            // check if given property is actually array
		                            if (typeof q === OBJ_TYPE && q.length > 0) {
		                                if (q.length === 2) {
		                                    if (typeof q[1] == FUNC_TYPE) {
		                                        // assign modified match
		                                        this[q[0]] = q[1].call(this, match);
		                                    } else {
		                                        // assign given value, ignore regex match
		                                        this[q[0]] = q[1];
		                                    }
		                                } else if (q.length === 3) {
		                                    // check whether function or regex
		                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
		                                        // call function (usually string mapper)
		                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;
		                                    } else {
		                                        // sanitize match using given regex
		                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;
		                                    }
		                                } else if (q.length === 4) {
		                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;
		                                }
		                            } else {
		                                this[q] = match ? match : undefined$1;
		                            }
		                        }
		                    }
		                }
		                i += 2;
		            }
		        },

		        strMapper = function (str, map) {

		            for (var i in map) {
		                // check if current value is array
		                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
		                    for (var j = 0; j < map[i].length; j++) {
		                        if (has(map[i][j], str)) {
		                            return (i === UNKNOWN) ? undefined$1 : i;
		                        }
		                    }
		                } else if (has(map[i], str)) {
		                    return (i === UNKNOWN) ? undefined$1 : i;
		                }
		            }
		            return str;
		    };

		    ///////////////
		    // String map
		    //////////////

		    // Safari < 3.0
		    var oldSafariMap = {
		            '1.0'   : '/8',
		            '1.2'   : '/1',
		            '1.3'   : '/3',
		            '2.0'   : '/412',
		            '2.0.2' : '/416',
		            '2.0.3' : '/417',
		            '2.0.4' : '/419',
		            '?'     : '/'
		        },
		        windowsVersionMap = {
		            'ME'        : '4.90',
		            'NT 3.11'   : 'NT3.51',
		            'NT 4.0'    : 'NT4.0',
		            '2000'      : 'NT 5.0',
		            'XP'        : ['NT 5.1', 'NT 5.2'],
		            'Vista'     : 'NT 6.0',
		            '7'         : 'NT 6.1',
		            '8'         : 'NT 6.2',
		            '8.1'       : 'NT 6.3',
		            '10'        : ['NT 6.4', 'NT 10.0'],
		            'RT'        : 'ARM'
		    };

		    //////////////
		    // Regex map
		    /////////////

		    var regexes = {

		        browser : [[

		            /\b(?:crmo|crios)\/([\w\.]+)/i                                      // Chrome for Android/iOS
		            ], [VERSION, [NAME, 'Chrome']], [
		            /edg(?:e|ios|a)?\/([\w\.]+)/i                                       // Microsoft Edge
		            ], [VERSION, [NAME, 'Edge']], [

		            // Presto based
		            /(opera mini)\/([-\w\.]+)/i,                                        // Opera Mini
		            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,                 // Opera Mobi/Tablet
		            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i                           // Opera
		            ], [NAME, VERSION], [
		            /opios[\/ ]+([\w\.]+)/i                                             // Opera mini on iphone >= 8.0
		            ], [VERSION, [NAME, OPERA+' Mini']], [
		            /\bopr\/([\w\.]+)/i                                                 // Opera Webkit
		            ], [VERSION, [NAME, OPERA]], [

		            // Mixed
		            /(kindle)\/([\w\.]+)/i,                                             // Kindle
		            /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,      // Lunascape/Maxthon/Netfront/Jasmine/Blazer
		            // Trident based
		            /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,               // Avant/IEMobile/SlimBrowser
		            /(ba?idubrowser)[\/ ]?([\w\.]+)/i,                                  // Baidu Browser
		            /(?:ms|\()(ie) ([\w\.]+)/i,                                         // Internet Explorer

		            // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
		            /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
		                                                                                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
		            /(heytap|ovi)browser\/([\d\.]+)/i,                                  // Heytap/Ovi
		            /(weibo)__([\d\.]+)/i                                               // Weibo
		            ], [NAME, VERSION], [
		            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i                 // UCBrowser
		            ], [VERSION, [NAME, 'UC'+BROWSER]], [
		            /microm.+\bqbcore\/([\w\.]+)/i,                                     // WeChat Desktop for Windows Built-in Browser
		            /\bqbcore\/([\w\.]+).+microm/i
		            ], [VERSION, [NAME, 'WeChat(Win) Desktop']], [
		            /micromessenger\/([\w\.]+)/i                                        // WeChat
		            ], [VERSION, [NAME, 'WeChat']], [
		            /konqueror\/([\w\.]+)/i                                             // Konqueror
		            ], [VERSION, [NAME, 'Konqueror']], [
		            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i                       // IE11
		            ], [VERSION, [NAME, 'IE']], [
		            /ya(?:search)?browser\/([\w\.]+)/i                                  // Yandex
		            ], [VERSION, [NAME, 'Yandex']], [
		            /(avast|avg)\/([\w\.]+)/i                                           // Avast/AVG Secure Browser
		            ], [[NAME, /(.+)/, '$1 Secure '+BROWSER], VERSION], [
		            /\bfocus\/([\w\.]+)/i                                               // Firefox Focus
		            ], [VERSION, [NAME, FIREFOX+' Focus']], [
		            /\bopt\/([\w\.]+)/i                                                 // Opera Touch
		            ], [VERSION, [NAME, OPERA+' Touch']], [
		            /coc_coc\w+\/([\w\.]+)/i                                            // Coc Coc Browser
		            ], [VERSION, [NAME, 'Coc Coc']], [
		            /dolfin\/([\w\.]+)/i                                                // Dolphin
		            ], [VERSION, [NAME, 'Dolphin']], [
		            /coast\/([\w\.]+)/i                                                 // Opera Coast
		            ], [VERSION, [NAME, OPERA+' Coast']], [
		            /miuibrowser\/([\w\.]+)/i                                           // MIUI Browser
		            ], [VERSION, [NAME, 'MIUI '+BROWSER]], [
		            /fxios\/([-\w\.]+)/i                                                // Firefox for iOS
		            ], [VERSION, [NAME, FIREFOX]], [
		            /\bqihu|(qi?ho?o?|360)browser/i                                     // 360
		            ], [[NAME, '360 '+BROWSER]], [
		            /(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i
		            ], [[NAME, /(.+)/, '$1 '+BROWSER], VERSION], [                      // Oculus/Samsung/Sailfish/Huawei Browser
		            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
		            ], [[NAME, /_/g, ' '], VERSION], [
		            /(electron)\/([\w\.]+) safari/i,                                    // Electron-based App
		            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,                   // Tesla
		            /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i            // QQBrowser/Baidu App/2345 Browser
		            ], [NAME, VERSION], [
		            /(metasr)[\/ ]?([\w\.]+)/i,                                         // SouGouBrowser
		            /(lbbrowser)/i,                                                     // LieBao Browser
		            /\[(linkedin)app\]/i                                                // LinkedIn App for iOS & Android
		            ], [NAME], [

		            // WebView
		            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i       // Facebook App for iOS & Android
		            ], [[NAME, FACEBOOK], VERSION], [
		            /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,                             // Kakao App
		            /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,                                  // Naver InApp
		            /safari (line)\/([\w\.]+)/i,                                        // Line App for iOS
		            /\b(line)\/([\w\.]+)\/iab/i,                                        // Line App for Android
		            /(chromium|instagram)[\/ ]([-\w\.]+)/i                              // Chromium/Instagram
		            ], [NAME, VERSION], [
		            /\bgsa\/([\w\.]+) .*safari\//i                                      // Google Search Appliance on iOS
		            ], [VERSION, [NAME, 'GSA']], [
		            /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i                        // TikTok
		            ], [VERSION, [NAME, 'TikTok']], [

		            /headlesschrome(?:\/([\w\.]+)| )/i                                  // Chrome Headless
		            ], [VERSION, [NAME, CHROME+' Headless']], [

		            / wv\).+(chrome)\/([\w\.]+)/i                                       // Chrome WebView
		            ], [[NAME, CHROME+' WebView'], VERSION], [

		            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i           // Android Browser
		            ], [VERSION, [NAME, 'Android '+BROWSER]], [

		            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i       // Chrome/OmniWeb/Arora/Tizen/Nokia
		            ], [NAME, VERSION], [

		            /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i                      // Mobile Safari
		            ], [VERSION, [NAME, 'Mobile Safari']], [
		            /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i                // Safari & Safari Mobile
		            ], [VERSION, NAME], [
		            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i                      // Safari < 3.0
		            ], [NAME, [VERSION, strMapper, oldSafariMap]], [

		            /(webkit|khtml)\/([\w\.]+)/i
		            ], [NAME, VERSION], [

		            // Gecko based
		            /(navigator|netscape\d?)\/([-\w\.]+)/i                              // Netscape
		            ], [[NAME, 'Netscape'], VERSION], [
		            /mobile vr; rv:([\w\.]+)\).+firefox/i                               // Firefox Reality
		            ], [VERSION, [NAME, FIREFOX+' Reality']], [
		            /ekiohf.+(flow)\/([\w\.]+)/i,                                       // Flow
		            /(swiftfox)/i,                                                      // Swiftfox
		            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
		                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
		            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
		                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
		            /(firefox)\/([\w\.]+)/i,                                            // Other Firefox-based
		            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,                         // Mozilla

		            // Other
		            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
		                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
		            /(links) \(([\w\.]+)/i,                                             // Links
		            /panasonic;(viera)/i                                                // Panasonic Viera
		            ], [NAME, VERSION], [
		            
		            /(cobalt)\/([\w\.]+)/i                                              // Cobalt
		            ], [NAME, [VERSION, /master.|lts./, ""]]
		        ],

		        cpu : [[

		            /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i                     // AMD64 (x64)
		            ], [[ARCHITECTURE, 'amd64']], [

		            /(ia32(?=;))/i                                                      // IA32 (quicktime)
		            ], [[ARCHITECTURE, lowerize]], [

		            /((?:i[346]|x)86)[;\)]/i                                            // IA32 (x86)
		            ], [[ARCHITECTURE, 'ia32']], [

		            /\b(aarch64|arm(v?8e?l?|_?64))\b/i                                 // ARM64
		            ], [[ARCHITECTURE, 'arm64']], [

		            /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i                                   // ARMHF
		            ], [[ARCHITECTURE, 'armhf']], [

		            // PocketPC mistakenly identified as PowerPC
		            /windows (ce|mobile); ppc;/i
		            ], [[ARCHITECTURE, 'arm']], [

		            /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i                            // PowerPC
		            ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [

		            /(sun4\w)[;\)]/i                                                    // SPARC
		            ], [[ARCHITECTURE, 'sparc']], [

		            /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
		                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
		            ], [[ARCHITECTURE, lowerize]]
		        ],

		        device : [[

		            //////////////////////////
		            // MOBILES & TABLETS
		            /////////////////////////

		            // Samsung
		            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
		            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [
		            /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
		            /samsung[- ]([-\w]+)/i,
		            /sec-(sgh\w+)/i
		            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [

		            // Apple
		            /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i                          // iPod/iPhone
		            ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [
		            /\((ipad);[-\w\),; ]+apple/i,                                       // iPad
		            /applecoremedia\/[\w\.]+ \((ipad)/i,
		            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
		            ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [
		            /(macintosh);/i
		            ], [MODEL, [VENDOR, APPLE]], [

		            // Sharp
		            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
		            ], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [

		            // Huawei
		            /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
		            ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [
		            /(?:huawei|honor)([-\w ]+)[;\)]/i,
		            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
		            ], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [

		            // Xiaomi
		            /\b(poco[\w ]+)(?: bui|\))/i,                                       // Xiaomi POCO
		            /\b; (\w+) build\/hm\1/i,                                           // Xiaomi Hongmi 'numeric' models
		            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,                             // Xiaomi Hongmi
		            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,                   // Xiaomi Redmi
		            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i // Xiaomi Mi
		            ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [
		            /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i                        // Mi Pad tablets
		            ],[[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [

		            // OPPO
		            /; (\w+) bui.+ oppo/i,
		            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
		            ], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [

		            // Vivo
		            /vivo (\w+)(?: bui|\))/i,
		            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
		            ], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [

		            // Realme
		            /\b(rmx[12]\d{3})(?: bui|;|\))/i
		            ], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [

		            // Motorola
		            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
		            /\bmot(?:orola)?[- ](\w*)/i,
		            /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
		            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [
		            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
		            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [

		            // LG
		            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
		            ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [
		            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
		            /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
		            /\blg-?([\d\w]+) bui/i
		            ], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [

		            // Lenovo
		            /(ideatab[-\w ]+)/i,
		            /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
		            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [

		            // Nokia
		            /(?:maemo|nokia).*(n900|lumia \d+)/i,
		            /nokia[-_ ]?([-\w\.]*)/i
		            ], [[MODEL, /_/g, ' '], [VENDOR, 'Nokia'], [TYPE, MOBILE]], [

		            // Google
		            /(pixel c)\b/i                                                      // Google Pixel C
		            ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [
		            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i                         // Google Pixel
		            ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [

		            // Sony
		            /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
		            ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [
		            /sony tablet [ps]/i,
		            /\b(?:sony)?sgp\w+(?: bui|\))/i
		            ], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [

		            // OnePlus
		            / (kb2005|in20[12]5|be20[12][59])\b/i,
		            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
		            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

		            // Amazon
		            /(alexa)webm/i,
		            /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i,                             // Kindle Fire without Silk / Echo Show
		            /(kf[a-z]+)( bui|\)).+silk\//i                                      // Kindle Fire HD
		            ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [
		            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i                     // Fire Phone
		            ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [

		            // BlackBerry
		            /(playbook);[-\w\),; ]+(rim)/i                                      // BlackBerry PlayBook
		            ], [MODEL, VENDOR, [TYPE, TABLET]], [
		            /\b((?:bb[a-f]|st[hv])100-\d)/i,
		            /\(bb10; (\w+)/i                                                    // BlackBerry 10
		            ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [

		            // Asus
		            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
		            ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [
		            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
		            ], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [

		            // HTC
		            /(nexus 9)/i                                                        // HTC Nexus 9
		            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [
		            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,                         // HTC

		            // ZTE
		            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
		            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i         // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
		            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

		            // Acer
		            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
		            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

		            // Meizu
		            /droid.+; (m[1-5] note) bui/i,
		            /\bmz-([-\w]{2,})/i
		            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [

		            // MIXED
		            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
		                                                                                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
		            /(hp) ([\w ]+\w)/i,                                                 // HP iPAQ
		            /(asus)-?(\w+)/i,                                                   // Asus
		            /(microsoft); (lumia[\w ]+)/i,                                      // Microsoft Lumia
		            /(lenovo)[-_ ]?([-\w]+)/i,                                          // Lenovo
		            /(jolla)/i,                                                         // Jolla
		            /(oppo) ?([\w ]+) bui/i                                             // OPPO
		            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

		            /(kobo)\s(ereader|touch)/i,                                         // Kobo
		            /(archos) (gamepad2?)/i,                                            // Archos
		            /(hp).+(touchpad(?!.+tablet)|tablet)/i,                             // HP TouchPad
		            /(kindle)\/([\w\.]+)/i,                                             // Kindle
		            /(nook)[\w ]+build\/(\w+)/i,                                        // Nook
		            /(dell) (strea[kpr\d ]*[\dko])/i,                                   // Dell Streak
		            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,                                  // Le Pan Tablets
		            /(trinity)[- ]*(t\d{3}) bui/i,                                      // Trinity Tablets
		            /(gigaset)[- ]+(q\w{1,9}) bui/i,                                    // Gigaset Tablets
		            /(vodafone) ([\w ]+)(?:\)| bui)/i                                   // Vodafone
		            ], [VENDOR, MODEL, [TYPE, TABLET]], [

		            /(surface duo)/i                                                    // Surface Duo
		            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [
		            /droid [\d\.]+; (fp\du?)(?: b|\))/i                                 // Fairphone
		            ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [
		            /(u304aa)/i                                                         // AT&T
		            ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [
		            /\bsie-(\w*)/i                                                      // Siemens
		            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [
		            /\b(rct\w+) b/i                                                     // RCA Tablets
		            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [
		            /\b(venue[\d ]{2,7}) b/i                                            // Dell Venue Tablets
		            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [
		            /\b(q(?:mv|ta)\w+) b/i                                              // Verizon Tablet
		            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [
		            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i                       // Barnes & Noble Tablet
		            ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [
		            /\b(tm\d{3}\w+) b/i
		            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [
		            /\b(k88) b/i                                                        // ZTE K Series Tablet
		            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [
		            /\b(nx\d{3}j) b/i                                                   // ZTE Nubia
		            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [
		            /\b(gen\d{3}) b.+49h/i                                              // Swiss GEN Mobile
		            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [
		            /\b(zur\d{3}) b/i                                                   // Swiss ZUR Tablet
		            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [
		            /\b((zeki)?tb.*\b) b/i                                              // Zeki Tablets
		            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [
		            /\b([yr]\d{2}) b/i,
		            /\b(dragon[- ]+touch |dt)(\w{5}) b/i                                // Dragon Touch Tablet
		            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [
		            /\b(ns-?\w{0,9}) b/i                                                // Insignia Tablets
		            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [
		            /\b((nxa|next)-?\w{0,9}) b/i                                        // NextBook Tablets
		            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [
		            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i                  // Voice Xtreme Phones
		            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [
		            /\b(lvtel\-)?(v1[12]) b/i                                           // LvTel Phones
		            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [
		            /\b(ph-1) /i                                                        // Essential PH-1
		            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [
		            /\b(v(100md|700na|7011|917g).*\b) b/i                               // Envizen Tablets
		            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [
		            /\b(trio[-\w\. ]+) b/i                                              // MachSpeed Tablets
		            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [
		            /\btu_(1491) b/i                                                    // Rotor Tablets
		            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [
		            /(shield[\w ]+) b/i                                                 // Nvidia Shield Tablets
		            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, TABLET]], [
		            /(sprint) (\w+)/i                                                   // Sprint Phones
		            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
		            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
		            ], [[MODEL, /\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [
		            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i             // Zebra
		            ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [
		            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
		            ], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [

		            ///////////////////
		            // SMARTTVS
		            ///////////////////

		            /smart-tv.+(samsung)/i                                              // Samsung
		            ], [VENDOR, [TYPE, SMARTTV]], [
		            /hbbtv.+maple;(\d+)/i
		            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [
		            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i        // LG SmartTV
		            ], [[VENDOR, LG], [TYPE, SMARTTV]], [
		            /(apple) ?tv/i                                                      // Apple TV
		            ], [VENDOR, [MODEL, APPLE+' TV'], [TYPE, SMARTTV]], [
		            /crkey/i                                                            // Google Chromecast
		            ], [[MODEL, CHROME+'cast'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
		            /droid.+aft(\w)( bui|\))/i                                          // Fire TV
		            ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [
		            /\(dtv[\);].+(aquos)/i,
		            /(aquos-tv[\w ]+)\)/i                                               // Sharp
		            ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],[
		            /(bravia[\w ]+)( bui|\))/i                                              // Sony
		            ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [
		            /(mitv-\w{5}) bui/i                                                 // Xiaomi
		            ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [
		            /Hbbtv.*(technisat) (.*);/i                                         // TechniSAT
		            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
		            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,                          // Roku
		            /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i         // HbbTV devices
		            ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [
		            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i                   // SmartTV from Unidentified Vendors
		            ], [[TYPE, SMARTTV]], [

		            ///////////////////
		            // CONSOLES
		            ///////////////////

		            /(ouya)/i,                                                          // Ouya
		            /(nintendo) ([wids3utch]+)/i                                        // Nintendo
		            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [
		            /droid.+; (shield) bui/i                                            // Nvidia
		            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [
		            /(playstation [345portablevi]+)/i                                   // Playstation
		            ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [
		            /\b(xbox(?: one)?(?!; xbox))[\); ]/i                                // Microsoft Xbox
		            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [

		            ///////////////////
		            // WEARABLES
		            ///////////////////

		            /((pebble))app/i                                                    // Pebble
		            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [
		            /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i                              // Apple Watch
		            ], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [
		            /droid.+; (glass) \d/i                                              // Google Glass
		            ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [
		            /droid.+; (wt63?0{2,3})\)/i
		            ], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [
		            /(quest( 2| pro)?)/i                                                // Oculus Quest
		            ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [

		            ///////////////////
		            // EMBEDDED
		            ///////////////////

		            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i                              // Tesla
		            ], [VENDOR, [TYPE, EMBEDDED]], [
		            /(aeobc)\b/i                                                        // Echo Dot
		            ], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [

		            ////////////////////
		            // MIXED (GENERIC)
		            ///////////////////

		            /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i           // Android Phones from Unidentified Vendors
		            ], [MODEL, [TYPE, MOBILE]], [
		            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i       // Android Tablets from Unidentified Vendors
		            ], [MODEL, [TYPE, TABLET]], [
		            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i                      // Unidentifiable Tablet
		            ], [[TYPE, TABLET]], [
		            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i    // Unidentifiable Mobile
		            ], [[TYPE, MOBILE]], [
		            /(android[-\w\. ]{0,9});.+buil/i                                    // Generic Android Device
		            ], [MODEL, [VENDOR, 'Generic']]
		        ],

		        engine : [[

		            /windows.+ edge\/([\w\.]+)/i                                       // EdgeHTML
		            ], [VERSION, [NAME, EDGE+'HTML']], [

		            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i                         // Blink
		            ], [VERSION, [NAME, 'Blink']], [

		            /(presto)\/([\w\.]+)/i,                                             // Presto
		            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
		            /ekioh(flow)\/([\w\.]+)/i,                                          // Flow
		            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,                           // KHTML/Tasman/Links
		            /(icab)[\/ ]([23]\.[\d\.]+)/i,                                      // iCab
		            /\b(libweb)/i
		            ], [NAME, VERSION], [

		            /rv\:([\w\.]{1,9})\b.+(gecko)/i                                     // Gecko
		            ], [VERSION, NAME]
		        ],

		        os : [[

		            // Windows
		            /microsoft (windows) (vista|xp)/i                                   // Windows (iTunes)
		            ], [NAME, VERSION], [
		            /(windows) nt 6\.2; (arm)/i,                                        // Windows RT
		            /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,            // Windows Phone
		            /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
		            ], [NAME, [VERSION, strMapper, windowsVersionMap]], [
		            /(win(?=3|9|n)|win 9x )([nt\d\.]+)/i
		            ], [[NAME, 'Windows'], [VERSION, strMapper, windowsVersionMap]], [

		            // iOS/macOS
		            /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,              // iOS
		            /ios;fbsv\/([\d\.]+)/i,
		            /cfnetwork\/.+darwin/i
		            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [
		            /(mac os x) ?([\w\. ]*)/i,
		            /(macintosh|mac_powerpc\b)(?!.+haiku)/i                             // Mac OS
		            ], [[NAME, MAC_OS], [VERSION, /_/g, '.']], [

		            // Mobile OSes
		            /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i                    // Android-x86/HarmonyOS
		            ], [VERSION, NAME], [                                               // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
		            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
		            /(blackberry)\w*\/([\w\.]*)/i,                                      // Blackberry
		            /(tizen|kaios)[\/ ]([\w\.]+)/i,                                     // Tizen/KaiOS
		            /\((series40);/i                                                    // Series 40
		            ], [NAME, VERSION], [
		            /\(bb(10);/i                                                        // BlackBerry 10
		            ], [VERSION, [NAME, BLACKBERRY]], [
		            /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i         // Symbian
		            ], [VERSION, [NAME, 'Symbian']], [
		            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
		            ], [VERSION, [NAME, FIREFOX+' OS']], [
		            /web0s;.+rt(tv)/i,
		            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i                              // WebOS
		            ], [VERSION, [NAME, 'webOS']], [
		            /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i                              // watchOS
		            ], [VERSION, [NAME, 'watchOS']], [

		            // Google Chromecast
		            /crkey\/([\d\.]+)/i                                                 // Google Chromecast
		            ], [VERSION, [NAME, CHROME+'cast']], [
		            /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i                                  // Chromium OS
		            ], [[NAME, CHROMIUM_OS], VERSION],[

		            // Smart TVs
		            /panasonic;(viera)/i,                                               // Panasonic Viera
		            /(netrange)mmh/i,                                                   // Netrange
		            /(nettv)\/(\d+\.[\w\.]+)/i,                                         // NetTV

		            // Console
		            /(nintendo|playstation) ([wids345portablevuch]+)/i,                 // Nintendo/Playstation
		            /(xbox); +xbox ([^\);]+)/i,                                         // Microsoft Xbox (360, One, X, S, Series X, Series S)

		            // Other
		            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,                            // Joli/Palm
		            /(mint)[\/\(\) ]?(\w*)/i,                                           // Mint
		            /(mageia|vectorlinux)[; ]/i,                                        // Mageia/VectorLinux
		            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
		                                                                                // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
		            /(hurd|linux) ?([\w\.]*)/i,                                         // Hurd/Linux
		            /(gnu) ?([\w\.]*)/i,                                                // GNU
		            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
		            /(haiku) (\w+)/i                                                    // Haiku
		            ], [NAME, VERSION], [
		            /(sunos) ?([\w\.\d]*)/i                                             // Solaris
		            ], [[NAME, 'Solaris'], VERSION], [
		            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,                              // Solaris
		            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,                                  // AIX
		            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
		            /(unix) ?([\w\.]*)/i                                                // UNIX
		            ], [NAME, VERSION]
		        ]
		    };

		    /////////////////
		    // Constructor
		    ////////////////

		    var UAParser = function (ua, extensions) {

		        if (typeof ua === OBJ_TYPE) {
		            extensions = ua;
		            ua = undefined$1;
		        }

		        if (!(this instanceof UAParser)) {
		            return new UAParser(ua, extensions).getResult();
		        }

		        var _navigator = (typeof window !== UNDEF_TYPE && window.navigator) ? window.navigator : undefined$1;
		        var _ua = ua || ((_navigator && _navigator.userAgent) ? _navigator.userAgent : EMPTY);
		        var _uach = (_navigator && _navigator.userAgentData) ? _navigator.userAgentData : undefined$1;
		        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
		        var _isSelfNav = _navigator && _navigator.userAgent == _ua;

		        this.getBrowser = function () {
		            var _browser = {};
		            _browser[NAME] = undefined$1;
		            _browser[VERSION] = undefined$1;
		            rgxMapper.call(_browser, _ua, _rgxmap.browser);
		            _browser[MAJOR] = majorize(_browser[VERSION]);
		            // Brave-specific detection
		            if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
		                _browser[NAME] = 'Brave';
		            }
		            return _browser;
		        };
		        this.getCPU = function () {
		            var _cpu = {};
		            _cpu[ARCHITECTURE] = undefined$1;
		            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
		            return _cpu;
		        };
		        this.getDevice = function () {
		            var _device = {};
		            _device[VENDOR] = undefined$1;
		            _device[MODEL] = undefined$1;
		            _device[TYPE] = undefined$1;
		            rgxMapper.call(_device, _ua, _rgxmap.device);
		            if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
		                _device[TYPE] = MOBILE;
		            }
		            // iPadOS-specific detection: identified as Mac, but has some iOS-only properties
		            if (_isSelfNav && _device[MODEL] == 'Macintosh' && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
		                _device[MODEL] = 'iPad';
		                _device[TYPE] = TABLET;
		            }
		            return _device;
		        };
		        this.getEngine = function () {
		            var _engine = {};
		            _engine[NAME] = undefined$1;
		            _engine[VERSION] = undefined$1;
		            rgxMapper.call(_engine, _ua, _rgxmap.engine);
		            return _engine;
		        };
		        this.getOS = function () {
		            var _os = {};
		            _os[NAME] = undefined$1;
		            _os[VERSION] = undefined$1;
		            rgxMapper.call(_os, _ua, _rgxmap.os);
		            if (_isSelfNav && !_os[NAME] && _uach && _uach.platform != 'Unknown') {
		                _os[NAME] = _uach.platform  
		                                    .replace(/chrome os/i, CHROMIUM_OS)
		                                    .replace(/macos/i, MAC_OS);           // backward compatibility
		            }
		            return _os;
		        };
		        this.getResult = function () {
		            return {
		                ua      : this.getUA(),
		                browser : this.getBrowser(),
		                engine  : this.getEngine(),
		                os      : this.getOS(),
		                device  : this.getDevice(),
		                cpu     : this.getCPU()
		            };
		        };
		        this.getUA = function () {
		            return _ua;
		        };
		        this.setUA = function (ua) {
		            _ua = (typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH) ? trim(ua, UA_MAX_LENGTH) : ua;
		            return this;
		        };
		        this.setUA(_ua);
		        return this;
		    };

		    UAParser.VERSION = LIBVERSION;
		    UAParser.BROWSER =  enumerize([NAME, VERSION, MAJOR]);
		    UAParser.CPU = enumerize([ARCHITECTURE]);
		    UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
		    UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);

		    ///////////
		    // Export
		    //////////

		    // check js environment
		    {
		        // nodejs env
		        if (module.exports) {
		            exports = module.exports = UAParser;
		        }
		        exports.UAParser = UAParser;
		    }

		    // jQuery/Zepto specific (optional)
		    // Note:
		    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
		    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
		    //   and we should catch that.
		    var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);
		    if ($ && !$.ua) {
		        var parser = new UAParser();
		        $.ua = parser.getResult();
		        $.ua.get = function () {
		            return parser.getUA();
		        };
		        $.ua.set = function (ua) {
		            parser.setUA(ua);
		            var result = parser.getResult();
		            for (var prop in result) {
		                $.ua[prop] = result[prop];
		            }
		        };
		    }

		})(typeof window === 'object' ? window : commonjsGlobal); 
	} (uaParser, uaParser.exports));

	var uaParserExports = uaParser.exports;
	var UAParser = /*@__PURE__*/getDefaultExportFromCjs$1(uaParserExports);

	/**
	 * Gets query string based on a data provider type
	 * @param dataProviderType
	 * @returns query string
	 */
	const getQueryStringForDataProviderType = (dataProviderType) => {
	    return `script[type='application/json'][data-provider-type='${dataProviderType}']`;
	};
	/**
	 * Gets data layer content as javascript object
	 * @param scriptTag
	 * @returns
	 */
	const getJsonFromDataLayer = (scriptTag) => {
	    if (scriptTag != null) {
	        try {
	            // Remove all white spaces before parsing the JSON string
	            return JSON.parse(scriptTag.textContent.replace(/\s/g, ''));
	        }
	        catch (e) {
	            Logger.warn('Failed to parse data layer JSON');
	        }
	    }
	    return null;
	};
	/**
	 * Parses user agent string and returns the results of the parsing (os,ua, device etc.)
	 * @returns
	 */
	const parseUserAgent = () => {
	    const parser = new UAParser();
	    const { browser, device, os } = parser.getResult();
	    const { name: browserName, version: browserVersion } = browser;
	    const { vendor: deviceVendor, model: deviceModel } = device;
	    const { name: osName, version: osVersion } = os;
	    return {
	        browserName,
	        browserVersion,
	        deviceVendor,
	        deviceModel,
	        osName,
	        osVersion,
	    };
	};
	/**
	 * Parses user agent string and returns the results of the parsing (os,ua, device etc.)
	 * @returns
	 */
	const getScreenResolution = () => {
	    return {
	        screenWidth: window.screen.width,
	        screenHeight: window.screen.height,
	    };
	};
	/**
	 * Adds user data to interaction event if available
	 * @param event
	 * @param userData
	 */
	const maybeAddUserToInteractionEvent = (event, userData) => {
	    if (userData) {
	        event.user = userData;
	    }
	};
	/**
	 * Adds source/page data to interaction event if available
	 * @param event
	 * @param sourceData
	 */
	const maybeAddSourceDataToInteractionEvent = (event, sourceData) => {
	    if (sourceData) {
	        event.source = sourceData;
	    }
	};
	/**
	 * Returns catalog object from an experience_interaction event details
	 * @param catalogObjectInteractionDetails
	 * @returns
	 */
	const getCatalogObjectFromExperienceEvent = (catalogObjectInteractionDetails) => {
	    const catalogObjects = catalogObjectInteractionDetails.catalogObjects;
	    if (Array.isArray(catalogObjects)) {
	        // currently, IS can only view one catalog object at a time. Just take the first one in array.
	        return catalogObjects[0];
	    }
	    else {
	        return catalogObjects;
	    }
	};
	/**
	 * Get all catalog objects from data layer
	 * @param catalogObjectType
	 * @param catalogObjectId
	 * @returns CatalogObject array
	 */
	const getCatalogObjectDataFromDataLayer = (catalogObjectType, catalogObjectId) => {
	    return Array.from(document.querySelectorAll(getQueryStringForDataProviderType(DATA_PROVIDER_TYPE_CATALOG)))
	        .flatMap((catalogObjectTag) => {
	        return getJsonFromDataLayer(catalogObjectTag);
	    })
	        .filter((catalogObjectData) => {
	        return catalogObjectData.type == catalogObjectType && catalogObjectData.id == catalogObjectId;
	    });
	};
	/**
	 * Gets cart from an CommerceCartInteractionDetails
	 * @param experienceEvent
	 * @returns CommerceCart
	 */
	const getCartFromExperienceEvent = (experienceEvent) => {
	    return experienceEvent.cart;
	};
	/**
	 * Gets cart data from data layer
	 * @returns CommerceCart or null
	 */
	const getCartDataFromDataLayer = () => {
	    const cartDataTag = document.querySelector(getQueryStringForDataProviderType(DATA_PROVIDER_TYPE_CART));
	    return getJsonFromDataLayer(cartDataTag);
	};
	/**
	 * Gets site data from data layer
	 * @returns Site or null
	 */
	const getSiteDataFromDataLayer = () => {
	    const siteDataTag = document.querySelector(getQueryStringForDataProviderType(DATA_PROVIDER_TYPE_SITE));
	    return getJsonFromDataLayer(siteDataTag);
	};
	/**
	 * Gets the componentId from data-component-id attribute
	 * @param element
	 * @returns componentId
	 */
	const getComponentId = (element) => {
	    var _a;
	    //Find the closest element which has a data-component-id attribute
	    if (element && 'closest' in element) {
	        const elementWithComponentIdAttribute = element.closest('[data-component-id]');
	        return (_a = elementWithComponentIdAttribute === null || elementWithComponentIdAttribute === void 0 ? void 0 : elementWithComponentIdAttribute.dataset) === null || _a === void 0 ? void 0 : _a.componentId;
	    }
	};
	/**
	 * Gets page data from page data layer
	 * @returns Page or null
	 */
	const getPageDataFromDataLayer = () => {
	    const pageDataTag = document.querySelector(getQueryStringForDataProviderType(DATA_PROVIDER_TYPE_PAGE));
	    return getJsonFromDataLayer(pageDataTag);
	};
	/**
	 * Gets user data from user data layer
	 * @returns User or null
	 */
	const getUserDataFromDataLayer = () => {
	    const userDataTag = document.querySelector(getQueryStringForDataProviderType(DATA_PROVIDER_TYPE_USER));
	    return getJsonFromDataLayer(userDataTag);
	};
	/**
	 * Gets the source interaction event
	 * @param pageData
	 * @returns
	 */
	const getSourceForInteractionEvent = (pageData) => {
	    return pageData
	        ? {
	            pageType: pageData.type,
	            locale: pageData.locale,
	            url: pageData.url,
	            urlReferrer: pageData.urlReferrer,
	        }
	        : null;
	};
	/**
	 * Formats user data to create an identity event
	 * @param userData
	 * @returns User or null
	 */
	const getUserForInteractionEvent = (userData) => {
	    var _a;
	    const userAttributes = (_a = userData === null || userData === void 0 ? void 0 : userData.attributes) !== null && _a !== void 0 ? _a : {};
	    return userData
	        ? {
	            crmId: userData.crmId,
	            attributes: { ...userAttributes, eventType: 'identity' },
	        }
	        : null;
	};
	/**
	 * Sets anonymous id
	 * @param experienceInteractionData
	 */
	const setAnonymousIdFromGuestUuid = (experienceInteractionData) => {
	    const guestUuid = experienceInteractionData.guestUuid;
	    if (guestUuid) {
	        setAnonymousId(guestUuid);
	    }
	};
	/**
	 * Sends a user interaction event
	 * @param eventData
	 * @returns
	 */
	const sendUserInteractionEvent = (event) => {
	    const eventData = event.detail;
	    const componentId = getComponentId(event.target);
	    const pageDataFromDataLayer = getPageDataFromDataLayer();
	    const siteDataFromDataLayer = getSiteDataFromDataLayer();
	    if (!pageDataFromDataLayer) {
	        return;
	    }
	    const { name, ...restOfTheEventData } = eventData;
	    const interactionEvent = {
	        interaction: {
	            name,
	            eventType: 'userEngagement',
	            ...siteDataFromDataLayer,
	            ...restOfTheEventData,
	            ...parseUserAgent(),
	            ...getScreenResolution(),
	            componentId,
	        },
	    };
	    maybeAddUserToInteractionEvent(interactionEvent, getUserForInteractionEvent(getUserDataFromDataLayer()));
	    maybeAddSourceDataToInteractionEvent(interactionEvent, getSourceForInteractionEvent(pageDataFromDataLayer));
	    sendEvent(interactionEvent);
	};
	/**
	 * Finds the data layer traversing recursively till the root
	 * @param target
	 * @returns data layer content based on provider type or null
	 */
	const getDataFromDataLayerRecursively = (target, providerType) => {
	    if (target) {
	        let element = target;
	        while (element !== document.documentElement) {
	            const dataLayerElement = element.querySelector(`:scope > experience-data-layer-object`);
	            if (dataLayerElement) {
	                const dataLayerContentOfProviderType = dataLayerElement.querySelector(`[data-provider-type="${providerType}"]`);
	                if (dataLayerContentOfProviderType) {
	                    return JSON.parse(dataLayerContentOfProviderType.textContent.replace(/\s/g, ''));
	                }
	            }
	            element = element.parentElement;
	        }
	    }
	};
	const transformDataLayerToDLOForSearchResult = (searchResultData) => {
	    var _a;
	    const { id: searchResultId } = searchResultData;
	    const attributes = (_a = searchResultData === null || searchResultData === void 0 ? void 0 : searchResultData.attributes) !== null && _a !== void 0 ? _a : {};
	    const { title: searchResultTitle, absolutePosition: searchResultPosition, positionInPage: searchResultPositionInPage, pageNumber: searchResultPageNumber, correlationId: searchCorrelationId, } = attributes;
	    return {
	        searchResultId,
	        searchResultTitle,
	        searchResultPosition,
	        searchResultPositionInPage,
	        searchResultPageNumber,
	        searchCorrelationId,
	    };
	};

	/**
	 * Creates CatalogObjectInteraction from CatalogObjectInteractionDetails
	 * @param catalogObjectInteractionDetails
	 * @returns CatalogObjectInteraction
	 */
	const createCatalogObjectInteraction = (catalogObjectInteractionDetails) => {
	    if (!(catalogObjectInteractionDetails.name === EVENT_CATALOG_OBJECT_VIEW_START ||
	        catalogObjectInteractionDetails.name === EVENT_CATALOG_OBJECT_VIEW_STOP ||
	        catalogObjectInteractionDetails.name === EVENT_CATALOG_OBJECT_CLICK)) {
	        Logger.warn(`Interaction name ${catalogObjectInteractionDetails.name} not supported for a CatalogObjectInteraction`);
	        return;
	    }
	    const catalogObject = getCatalogObjectFromExperienceEvent(catalogObjectInteractionDetails);
	    const catalogObjectsFromDataLayer = getCatalogObjectDataFromDataLayer(catalogObject.type, catalogObject.id);
	    return {
	        name: catalogObjectInteractionDetails.name,
	        catalogObject: {
	            type: catalogObject.type,
	            id: catalogObject.id,
	            attributes: Object.assign({}, ...catalogObjectsFromDataLayer.map((catalogObjectFromDataLayer) => catalogObjectFromDataLayer.attributes)),
	            relatedCatalogObjects: Object.assign({}, ...catalogObjectsFromDataLayer.map((catalogObjectFromDataLayer) => catalogObjectFromDataLayer.relatedCatalogObjects)),
	        },
	    };
	};
	const createSearchInteraction = (searchInteractionDetails) => {
	    var _a;
	    const { name, searchQuery, categoryId } = searchInteractionDetails;
	    const attributes = (_a = searchInteractionDetails === null || searchInteractionDetails === void 0 ? void 0 : searchInteractionDetails.attributes) !== null && _a !== void 0 ? _a : {};
	    const { searchFacetList, searchType, ...rest } = attributes;
	    return {
	        name,
	        searchQuery,
	        categoryId,
	        searchFacetList: searchFacetList === null || searchFacetList === void 0 ? void 0 : searchFacetList.toString(),
	        searchType: searchType === null || searchType === void 0 ? void 0 : searchType.toString(),
	        ...rest,
	    };
	};

	/**
	 * Creates a cart interaction
	 * @param cartInteractionDetails
	 * @returns
	 */
	const createCartInteraction = (cartInteractionDetails) => {
	    var _a, _b, _c, _d, _e, _f, _g, _h;
	    if (cartInteractionDetails.name == EVENT_CART_ADD || cartInteractionDetails.name == EVENT_CART_REMOVE) {
	        const cartFromExperienceEvent = getCartFromExperienceEvent(cartInteractionDetails);
	        if (Array.isArray(cartFromExperienceEvent.lineItems)) {
	            Logger.warn('Attempting to read cart data layer but cart lineItem is not an object');
	            return;
	        }
	        const cartLineItem = {
	            catalogObjectId: (_a = cartFromExperienceEvent.lineItems) === null || _a === void 0 ? void 0 : _a.catalogObjectId,
	            catalogObjectType: (_b = cartFromExperienceEvent.lineItems) === null || _b === void 0 ? void 0 : _b.catalogObjectType,
	            price: (_d = (_c = cartFromExperienceEvent.lineItems) === null || _c === void 0 ? void 0 : _c.attributes) === null || _d === void 0 ? void 0 : _d.price,
	            quantity: (_f = (_e = cartFromExperienceEvent.lineItems) === null || _e === void 0 ? void 0 : _e.attributes) === null || _f === void 0 ? void 0 : _f.quantity,
	        };
	        if (isNaN(cartLineItem === null || cartLineItem === void 0 ? void 0 : cartLineItem.price)) {
	            Logger.warn('Attempting to read cart data layer but price could not be parsed');
	            return;
	        }
	        if ((_g = cartFromExperienceEvent.attributes) === null || _g === void 0 ? void 0 : _g.currency) {
	            cartLineItem.currency = (_h = cartFromExperienceEvent === null || cartFromExperienceEvent === void 0 ? void 0 : cartFromExperienceEvent.attributes) === null || _h === void 0 ? void 0 : _h.currency;
	        }
	        let cartInteraction;
	        const { name } = cartInteractionDetails;
	        if (cartInteractionDetails.name === EVENT_CART_ADD) {
	            cartInteraction = {
	                name,
	                lineItem: cartLineItem,
	            };
	        }
	        else {
	            cartInteraction = {
	                name,
	                lineItem: cartLineItem,
	            };
	        }
	        return cartInteraction;
	    }
	    else if (cartInteractionDetails.name == EVENT_CART_REPLACE) {
	        const cartFromDataLayer = getCartDataFromDataLayer();
	        if (!Array.isArray(cartFromDataLayer.lineItems)) {
	            Logger.warn('Attempting to read cart data layer but cart lineItems are not an array');
	            return;
	        }
	        const { currency, ...otherCartAttributes } = cartFromDataLayer.attributes;
	        if (otherCartAttributes) {
	            Logger.info('Salesforce Interactions Web SDK does not support cart attributes aside from currency');
	        }
	        const cartLineItems = cartFromDataLayer.lineItems.map((lineItem) => {
	            const { price, quantity, ...otherLineItemAttributes } = lineItem.attributes;
	            const cartLineItem = {
	                catalogObjectId: lineItem.catalogObjectId,
	                catalogObjectType: lineItem.catalogObjectType,
	                price: price,
	                quantity: quantity,
	            };
	            if (isNaN(cartLineItem.price)) {
	                Logger.warn('Attempting to read cart data layer but price could not be parsed');
	                return;
	            }
	            if (currency) {
	                cartLineItem.currency = currency;
	            }
	            if (otherLineItemAttributes) {
	                cartLineItem.attributes = otherLineItemAttributes;
	            }
	            return cartLineItem;
	        });
	        return {
	            name: cartInteractionDetails.name,
	            lineItems: cartLineItems,
	        };
	    }
	    else {
	        Logger.warn(`Interaction name ${cartInteractionDetails.name} not supported for a CartInteraction`);
	        return;
	    }
	};

	/**
	 * Creates an interaction object from an experience event details
	 * @param experienceInteractionDetails
	 * @returns interaction object
	 */
	const getInteractionFromExperienceEvent = (event) => {
	    const experienceInteractionDetails = event.detail;
	    if ('catalogObjects' in experienceInteractionDetails) {
	        const recommendationData = getDataFromDataLayerRecursively(event.target, DATA_PROVIDER_TYPE_RECOMMENDATION) || {};
	        const searchResultData = getDataFromDataLayerRecursively(event.target, DATA_PROVIDER_TYPE_SEARCH_RESULT);
	        const dloSearchResult = (searchResultData && transformDataLayerToDLOForSearchResult(searchResultData)) || {};
	        const catalogObjectInteraction = createCatalogObjectInteraction(experienceInteractionDetails);
	        return {
	            ...catalogObjectInteraction,
	            ...recommendationData,
	            ...dloSearchResult,
	            ...{
	                eventType: catalogObjectInteraction.catalogObject.type === CATALOG_OBJECT_TYPE_PRODUCT
	                    ? DATA_PROVIDER_TYPE_CATALOG
	                    : DLO_USER_ENGAGEMENT,
	            },
	        };
	    }
	    else if ('cart' in experienceInteractionDetails) {
	        return createCartInteraction(experienceInteractionDetails);
	    }
	    else if (experienceInteractionDetails.name === EVENT_SEARCH) {
	        return createSearchInteraction(experienceInteractionDetails);
	    }
	    else {
	        return { name: experienceInteractionDetails.name };
	    }
	};
	/**
	 * Event handler for experience_interaction events
	 * @param event
	 * @returns
	 */
	const handleCustomEvent = (event) => {
	    if (event && event.detail) {
	        const eventData = event.detail;
	        if (!eventData.name) {
	            return;
	        }
	        else if (eventData.name == EVENT_SET_GUEST_GUID) {
	            setAnonymousIdFromGuestUuid(eventData);
	            return;
	        }
	        else if (eventData.name == EVENT_USER_ENGAGEMENT ||
	            eventData.name == EVENT_SET_PAGE_VIEW ||
	            eventData.name == EVENT_PAGE_SCROLL_TO_BOTTOM) {
	            sendUserInteractionEvent(event);
	            return;
	        }
	        const interaction = getInteractionFromExperienceEvent(event);
	        if (interaction) {
	            const interactionEvent = {
	                interaction: {
	                    ...interaction,
	                    ...getSiteDataFromDataLayer(),
	                    ...parseUserAgent(),
	                    ...getScreenResolution(),
	                    componentId: getComponentId(event.target),
	                },
	            };
	            maybeAddUserToInteractionEvent(interactionEvent, getUserForInteractionEvent(getUserDataFromDataLayer()));
	            maybeAddSourceDataToInteractionEvent(interactionEvent, getSourceForInteractionEvent(getPageDataFromDataLayer()));
	            sendEvent(interactionEvent);
	        }
	    }
	};

	/**
	 * Handles all DOM click events from button or anchor elements
	 * @param event
	 * @returns
	 */
	const handleEvent = (event) => {
	    var _a;
	    if ((_a = window.dataCloudConfig) === null || _a === void 0 ? void 0 : _a.suppressDefaultEvents) {
	        return;
	    }
	    // Check if the event target is a button or anchor tag
	    if (!(event.target instanceof HTMLButtonElement || event.target instanceof HTMLAnchorElement)) {
	        return;
	    }
	    let target = event.target;
	    let engagementData = {};
	    const componentId = getComponentId(target);
	    // Add componentId to enagement if it is not undefined
	    componentId && (engagementData = { ...engagementData, componentId });
	    let eventName;
	    if (event.target instanceof HTMLAnchorElement) {
	        eventName = EVENT_ANCHOR_CLICK;
	        engagementData = {
	            ...engagementData,
	            linkHref: target.getAttribute('href'),
	            linkId: target.getAttribute('id'),
	            linkRel: target.getAttribute('rel'),
	            linkTarget: target.getAttribute('target'),
	            linkReferrerPolicy: target.getAttribute('referrerPolicy'),
	            linkLabel: target.textContent,
	        };
	    }
	    else {
	        eventName = EVENT_BUTTON_CLICK;
	        engagementData = {
	            ...engagementData,
	            buttonId: target.getAttribute('id'),
	            buttonLabel: target.textContent,
	            buttonType: target.getAttribute('type'),
	        };
	    }
	    // Traverse recursively to find the closest data layer
	    while (target.parentElement !== document.documentElement) {
	        const parent = target.parentElement;
	        // Select the data layer script element if it exists
	        const dataLayerScriptElement = document.querySelector("script[type='application/json][data-provider-type]");
	        // Contextual data layers are default added to each event sent to data cloud.
	        // We are looking for data providers that are non-contextual.
	        if (dataLayerScriptElement &&
	            !CONTEXTUAL_DATA_PROVIDER_TYPES.includes(dataLayerScriptElement.dataset.dataProviderType)) {
	            // Found the closest data layer
	            engagementData = { ...engagementData, ...JSON.parse(dataLayerScriptElement.textContent) };
	            break;
	        }
	        target = parent;
	    }
	    const siteDataFromDataLayer = getSiteDataFromDataLayer();
	    const interactionEvent = {
	        interaction: {
	            name: eventName,
	            eventType: DLO_USER_ENGAGEMENT,
	            ...engagementData,
	            ...parseUserAgent(),
	            ...getScreenResolution(),
	            ...siteDataFromDataLayer,
	        },
	    };
	    maybeAddUserToInteractionEvent(interactionEvent, getUserForInteractionEvent(getUserDataFromDataLayer()));
	    maybeAddSourceDataToInteractionEvent(interactionEvent, getSourceForInteractionEvent(getPageDataFromDataLayer()));
	    sendEvent(interactionEvent);
	};

	const experienceInteractionEventHandler = (events) => {
	    events.forEach((event) => {
	        event instanceof CustomEvent ? handleCustomEvent(event) : handleEvent(event);
	    });
	};

	function requireOptions(options, ...names) {
	  names.forEach((name) => {
	    if (options == null || Object.prototype.hasOwnProperty.call(options, name) === false || options[name] == null) {
	      throw new Error(`missing required option "${name.toString()}"`);
	    }
	  });
	}

	function validateTenantEndpoint(urlString, throwOnError = "") {
	  const httpsProtocol = "https://";
	  try {
	    urlString = urlString.trim();
	    if (!/^.+:\/\/.*/.test(urlString)) {
	      urlString = httpsProtocol + urlString;
	    }
	    urlString = httpsProtocol + new URL(urlString).hostname;
	    if (!urlString.endsWith(".salesforce.com")) {
	      throw new TypeError("Invalid URL: " + urlString);
	    }
	  } catch (error) {
	    urlString = "";
	    if (throwOnError !== "") {
	      throw new Error(throwOnError);
	    }
	  }
	  return urlString;
	}

	function dispatch(eventType, detail) {
	  const customEvent = new CustomEvent(eventType, {
	    detail
	  });
	  document.dispatchEvent(customEvent);
	}

	var __async$5 = (__this, __arguments, generator) => {
	  return new Promise((resolve, reject) => {
	    var fulfilled = (value) => {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    };
	    var rejected = (value) => {
	      try {
	        step(generator.throw(value));
	      } catch (e) {
	        reject(e);
	      }
	    };
	    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
	    step((generator = generator.apply(__this, __arguments)).next());
	  });
	};
	function promiseXHR(configureRequest) {
	  return __async$5(this, null, function* () {
	    return yield new Promise((resolve, reject) => {
	      const xhr = new XMLHttpRequest();
	      xhr.onload = () => resolve(xhr);
	      xhr.onerror = () => resolve(xhr);
	      xhr.abort = () => reject(new Error("Request aborted"));
	      configureRequest(xhr);
	    });
	  });
	}

	var __async$4 = (__this, __arguments, generator) => {
	  return new Promise((resolve, reject) => {
	    var fulfilled = (value) => {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    };
	    var rejected = (value) => {
	      try {
	        step(generator.throw(value));
	      } catch (e) {
	        reject(e);
	      }
	    };
	    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
	    step((generator = generator.apply(__this, __arguments)).next());
	  });
	};
	function delay(delay2) {
	  return __async$4(this, null, function* () {
	    yield new Promise((resolve) => {
	      setTimeout(resolve, delay2);
	    });
	  });
	}

	const MAX_GET_REQUEST_SIZE = 8192;
	var CDPResponseStatus = /* @__PURE__ */ ((CDPResponseStatus2) => {
	  CDPResponseStatus2[CDPResponseStatus2["OK"] = 200] = "OK";
	  CDPResponseStatus2[CDPResponseStatus2["NO_CONTENT"] = 204] = "NO_CONTENT";
	  CDPResponseStatus2[CDPResponseStatus2["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
	  CDPResponseStatus2[CDPResponseStatus2["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
	  return CDPResponseStatus2;
	})(CDPResponseStatus || {});

	function requestOK(xhr) {
	  return (xhr == null ? void 0 : xhr.status) === CDPResponseStatus.OK || (xhr == null ? void 0 : xhr.status) === CDPResponseStatus.NO_CONTENT;
	}

	function getSalesforceInteractionsInstance() {
	  return window.SalesforceInteractions;
	}

	function getSessionId() {
	  const sessionId = getSalesforceInteractionsInstance().getAnonymousId();
	  if (sessionId == null || sessionId === "") {
	    throw new Error("sessionId is missing");
	  }
	  return sessionId;
	}

	function getDeviceId(options) {
	  var _a;
	  return (_a = options.deviceId) != null ? _a : getSessionId();
	}

	var __async$3 = (__this, __arguments, generator) => {
	  return new Promise((resolve, reject) => {
	    var fulfilled = (value) => {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    };
	    var rejected = (value) => {
	      try {
	        step(generator.throw(value));
	      } catch (e) {
	        reject(e);
	      }
	    };
	    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
	    step((generator = generator.apply(__this, __arguments)).next());
	  });
	};
	const DEFAULT_RETRY_DELAY = 5;
	const DEFAULT_MAX_ATTEMPTS = 5;
	function createAuthenticator(options) {
	  var _a, _b;
	  const authenticationUrl = options.tenantSpecificEndpoint + "/web/authentication";
	  const maxAttempts = (_a = options.authenticator.maxAttempts) != null ? _a : DEFAULT_MAX_ATTEMPTS;
	  const retryDelay = (_b = options.authenticator.retryDelay) != null ? _b : DEFAULT_RETRY_DELAY;
	  let authenticated = false;
	  let authenticationFailed = false;
	  return () => __async$3(this, null, function* () {
	    if (authenticated) {
	      return true;
	    }
	    if (authenticationFailed) {
	      return false;
	    }
	    const attemptRequest = () => __async$3(this, null, function* () {
	      const xhr = yield promiseXHR((xhr2) => {
	        const encodedAuth = btoa(JSON.stringify({
	          appSourceId: options.authenticator.appSourceId,
	          deviceId: getDeviceId(options)
	        }));
	        xhr2.withCredentials = true;
	        xhr2.open("POST", authenticationUrl);
	        xhr2.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
	        xhr2.send(`auth=${encodedAuth}`);
	      });
	      if (xhr.status === CDPResponseStatus.UNAUTHORIZED) {
	        authenticationFailed = true;
	        throw new Error("Unauthorized");
	      }
	      return requestOK(xhr);
	    });
	    for (let i = maxAttempts; i > 0; i--) {
	      try {
	        authenticated = yield attemptRequest();
	        if (authenticated) {
	          return true;
	        }
	      } finally {
	        const keepTryingAuthentication = !(authenticated || authenticationFailed);
	        if (keepTryingAuthentication && i > 1) {
	          yield delay(retryDelay);
	        }
	      }
	    }
	    authenticationFailed = true;
	    throw new Error("No more authentication retries");
	  });
	}

	function toBase64(str) {
	  return btoa(encodeURIComponent(str).replace(
	    /%([0-9A-F]{2})/g,
	    (match, p1) => {
	      const code = p1.toString();
	      return String.fromCharCode(parseInt(`0x${code}`, 16));
	    }
	  ));
	}

	var __async$2 = (__this, __arguments, generator) => {
	  return new Promise((resolve, reject) => {
	    var fulfilled = (value) => {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    };
	    var rejected = (value) => {
	      try {
	        step(generator.throw(value));
	      } catch (e) {
	        reject(e);
	      }
	    };
	    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
	    step((generator = generator.apply(__this, __arguments)).next());
	  });
	};
	const ACCEPT_HEADER = "application/json, text/javascript, */*; q=0.01";
	function sendEvents(options, events) {
	  return __async$2(this, null, function* () {
	    const url = options.tenantSpecificEndpoint + "/web/events/" + options.authenticator.appSourceId;
	    const payload = { events };
	    getSalesforceInteractionsInstance().log.debug(`Sending events: ${JSON.stringify(events, convertBooleanToNumber, "	")}`);
	    const xhr = yield promiseXHR((xhr2) => {
	      const eventsAsJSON = JSON.stringify(payload, convertBooleanToNumber);
	      const containsNonAscii = !/^[\x20-\x7E]+$/.test(eventsAsJSON);
	      const eventsAsBase64 = encodeURIComponent(toBase64(eventsAsJSON));
	      const getUrl = `${url}?event=${eventsAsBase64}`;
	      const getUrlExceedsMaxGetRequestSize = getUrl.length > MAX_GET_REQUEST_SIZE;
	      xhr2.withCredentials = true;
	      if (containsNonAscii || getUrlExceedsMaxGetRequestSize) {
	        xhr2.open("POST", url, true);
	        xhr2.setRequestHeader("Accept", ACCEPT_HEADER);
	        xhr2.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
	        xhr2.send(`event=${eventsAsBase64}`);
	      } else {
	        xhr2.open("GET", getUrl, true);
	        xhr2.setRequestHeader("Accept", ACCEPT_HEADER);
	        xhr2.send();
	      }
	    });
	    if (!requestOK(xhr)) {
	      const error = new Error(`Response was not OK: ${xhr.responseText}`);
	      Object.assign(error, {
	        status: xhr.status,
	        statusText: xhr.statusText
	      });
	      throw error;
	    }
	  });
	}
	function convertBooleanToNumber(key, value) {
	  if (typeof value === "boolean") {
	    return value ? 1 : 0;
	  }
	  return value;
	}

	// Unique ID creation requires a high quality random # generator. In the browser we therefore
	// require the crypto API and do not support built-in fallback to lower quality random number
	// generators (like Math.random()).
	let getRandomValues;
	const rnds8 = new Uint8Array(16);
	function rng() {
	  // lazy load so that environments that need to polyfill have a chance to do so
	  if (!getRandomValues) {
	    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
	    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

	    if (!getRandomValues) {
	      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
	    }
	  }

	  return getRandomValues(rnds8);
	}

	/**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */

	const byteToHex = [];

	for (let i = 0; i < 256; ++i) {
	  byteToHex.push((i + 0x100).toString(16).slice(1));
	}

	function unsafeStringify(arr, offset = 0) {
	  // Note: Be careful editing this code!  It's been tuned for performance
	  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
	  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
	}

	const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
	var native = {
	  randomUUID
	};

	function v4(options, buf, offset) {
	  if (native.randomUUID && !buf && !options) {
	    return native.randomUUID();
	  }

	  options = options || {};
	  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

	  rnds[6] = rnds[6] & 0x0f | 0x40;
	  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

	  if (buf) {
	    offset = offset || 0;

	    for (let i = 0; i < 16; ++i) {
	      buf[offset + i] = rnds[i];
	    }

	    return buf;
	  }

	  return unsafeStringify(rnds);
	}

	function getEventDateTime(actionEvent) {
	  const sourceDate = typeof (actionEvent == null ? void 0 : actionEvent.time) === "number" ? new Date(actionEvent.time) : /* @__PURE__ */ new Date();
	  return sourceDate.toISOString();
	}

	var RequiredEventFields = /* @__PURE__ */ ((RequiredEventFields2) => {
	  RequiredEventFields2["Category"] = "category";
	  RequiredEventFields2["DateTime"] = "dateTime";
	  RequiredEventFields2["DeviceId"] = "deviceId";
	  RequiredEventFields2["EventId"] = "eventId";
	  RequiredEventFields2["EventType"] = "eventType";
	  RequiredEventFields2["SessionId"] = "sessionId";
	  return RequiredEventFields2;
	})(RequiredEventFields || {});
	var CDPEventType = /* @__PURE__ */ ((CDPEventType2) => {
	  CDPEventType2["Cart"] = "cart";
	  CDPEventType2["CartItem"] = "cartItem";
	  CDPEventType2["Catalog"] = "catalog";
	  CDPEventType2["Consent"] = "consentLog";
	  CDPEventType2["Order"] = "order";
	  CDPEventType2["OrderItem"] = "orderItem";
	  return CDPEventType2;
	})(CDPEventType || {});
	var InteractionEventFields = /* @__PURE__ */ ((InteractionEventFields2) => {
	  InteractionEventFields2["INTERACTION_NAME"] = "interactionName";
	  InteractionEventFields2["PAGE_VIEW"] = "pageView";
	  InteractionEventFields2["SOURCE_CHANNEL"] = "sourceChannel";
	  InteractionEventFields2["SOURCE_LOCALE"] = "sourceLocale";
	  InteractionEventFields2["SOURCE_PAGE_TYPE"] = "sourcePageType";
	  InteractionEventFields2["SOURCE_URL"] = "sourceUrl";
	  InteractionEventFields2["SOURCE_URL_REFERRER"] = "sourceUrlReferrer";
	  return InteractionEventFields2;
	})(InteractionEventFields || {});

	function getGeneratedEventFields(actionEvent, options) {
	  return {
	    [RequiredEventFields.EventId]: v4(),
	    [RequiredEventFields.DateTime]: getEventDateTime(actionEvent),
	    [RequiredEventFields.SessionId]: getSessionId(),
	    [RequiredEventFields.DeviceId]: getDeviceId(options)
	  };
	}

	var CDPEventCategory = /* @__PURE__ */ ((CDPEventCategory2) => {
	  CDPEventCategory2["Engagement"] = "Engagement";
	  CDPEventCategory2["Profile"] = "Profile";
	  return CDPEventCategory2;
	})(CDPEventCategory || {});
	function isOrder(order) {
	  return (order == null ? void 0 : order.id) != null;
	}
	function isCatalogObject(catalogObject) {
	  return (catalogObject == null ? void 0 : catalogObject.id) != null && (catalogObject == null ? void 0 : catalogObject.type) != null;
	}
	function isLineItem(lineItem) {
	  return (lineItem == null ? void 0 : lineItem.catalogObjectId) != null && (lineItem == null ? void 0 : lineItem.catalogObjectType) != null && (lineItem == null ? void 0 : lineItem.quantity) != null;
	}

	var __defProp$6 = Object.defineProperty;
	var __defProps$5 = Object.defineProperties;
	var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
	var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
	var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$6 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$6.call(b, prop))
	      __defNormalProp$6(a, prop, b[prop]);
	  if (__getOwnPropSymbols$6)
	    for (var prop of __getOwnPropSymbols$6(b)) {
	      if (__propIsEnum$6.call(b, prop))
	        __defNormalProp$6(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
	function extractConsentEvents(actionEvent, options) {
	  var _a;
	  const consents = (_a = actionEvent.consents) != null ? _a : [];
	  if (consents.length === 0) {
	    return [];
	  }
	  const consentEvents = [];
	  consents.forEach((consent) => {
	    const consentEvent = extractConsent(consent, actionEvent, options);
	    if (consentEvent != null) {
	      consentEvents.push(consentEvent);
	    }
	  });
	  return consentEvents;
	}
	function extractConsent(consent, actionEvent, options) {
	  try {
	    let status;
	    if (consent.status === ConsentStatus.OptIn) {
	      status = "opt-in";
	    } else if (consent.status === ConsentStatus.OptOut) {
	      status = "opt-out";
	    } else {
	      getSalesforceInteractionsInstance().log.error(`Consent value should be either "${ConsentStatus.OptIn}" or "${ConsentStatus.OptOut}"`, actionEvent);
	      return null;
	    }
	    return __spreadProps$5(__spreadValues$6({}, getGeneratedEventFields(actionEvent, options)), {
	      [RequiredEventFields.EventType]: CDPEventType.Consent,
	      [RequiredEventFields.Category]: CDPEventCategory.Engagement,
	      purpose: consent.purpose,
	      provider: consent.provider,
	      status
	    });
	  } catch (e) {
	    getSalesforceInteractionsInstance().log.error(e.message);
	    return null;
	  }
	}

	function getInteractionFields(actionEvent) {
	  var _a, _b, _c, _d, _e, _f;
	  return {
	    [InteractionEventFields.INTERACTION_NAME]: (_a = actionEvent == null ? void 0 : actionEvent.interaction) == null ? void 0 : _a.name,
	    [InteractionEventFields.PAGE_VIEW]: actionEvent == null ? void 0 : actionEvent.pageView,
	    [InteractionEventFields.SOURCE_URL]: (_b = actionEvent == null ? void 0 : actionEvent.source) == null ? void 0 : _b.url,
	    [InteractionEventFields.SOURCE_URL_REFERRER]: (_c = actionEvent == null ? void 0 : actionEvent.source) == null ? void 0 : _c.urlReferrer,
	    [InteractionEventFields.SOURCE_CHANNEL]: (_d = actionEvent == null ? void 0 : actionEvent.source) == null ? void 0 : _d.channel,
	    [InteractionEventFields.SOURCE_LOCALE]: (_e = actionEvent == null ? void 0 : actionEvent.source) == null ? void 0 : _e.locale,
	    [InteractionEventFields.SOURCE_PAGE_TYPE]: (_f = actionEvent == null ? void 0 : actionEvent.source) == null ? void 0 : _f.pageType
	  };
	}

	const validEventTypePattern = /^[a-zA-Z](?!.*__)(?!.*_$)\w{0,79}$/;
	function validateEventType(eventType) {
	  if (typeof eventType !== "string" || !validEventTypePattern.test(eventType)) {
	    getSalesforceInteractionsInstance().log.warn(`[Invalid eventType: "${eventType}"] Must begin with a letter (a-zA-Z) and can only contain alphanumeric characters and underscores (no spaces.) Also cannot end with or have consecutive underscores. Max 80 characters.`);
	    return null;
	  }
	  return eventType;
	}

	var __defProp$5 = Object.defineProperty;
	var __defProps$4 = Object.defineProperties;
	var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
	var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
	var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$5 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$5.call(b, prop))
	      __defNormalProp$5(a, prop, b[prop]);
	  if (__getOwnPropSymbols$5)
	    for (var prop of __getOwnPropSymbols$5(b)) {
	      if (__propIsEnum$5.call(b, prop))
	        __defNormalProp$5(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
	function extractProfileEvents(actionEvent, options) {
	  var _a;
	  const userAttributes = (_a = actionEvent == null ? void 0 : actionEvent.user) == null ? void 0 : _a.attributes;
	  if (typeof userAttributes !== "object") {
	    return [];
	  }
	  const eventType = validateEventType(userAttributes == null ? void 0 : userAttributes.eventType);
	  if (eventType == null) {
	    throw new Error(`Missing or invalid required "user.attributes.eventType" string in action: ${JSON.stringify(actionEvent, null, "	")}`);
	  }
	  return [__spreadProps$4(__spreadValues$5(__spreadValues$5(__spreadValues$5({}, getGeneratedEventFields(actionEvent, options)), getInteractionFields(actionEvent)), userAttributes), {
	    [RequiredEventFields.EventType]: eventType,
	    [RequiredEventFields.Category]: CDPEventCategory.Profile
	  })];
	}

	function copyParentFieldsForCDPEvent(parentEvent) {
	  return {
	    [RequiredEventFields.EventId]: v4(),
	    [RequiredEventFields.Category]: parentEvent[RequiredEventFields.Category],
	    [RequiredEventFields.DateTime]: parentEvent[RequiredEventFields.DateTime],
	    [RequiredEventFields.DeviceId]: parentEvent[RequiredEventFields.DeviceId],
	    [RequiredEventFields.SessionId]: parentEvent[RequiredEventFields.SessionId],
	    [RequiredEventFields.EventType]: ""
	  };
	}

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var camelcase = {exports: {}};

	const UPPERCASE = /[\p{Lu}]/u;
	const LOWERCASE = /[\p{Ll}]/u;
	const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
	const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
	const SEPARATORS = /[_.\- ]+/;

	const LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);
	const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');
	const NUMBERS_AND_IDENTIFIER = new RegExp('\\d+' + IDENTIFIER.source, 'gu');

	const preserveCamelCase = (string, toLowerCase, toUpperCase) => {
		let isLastCharLower = false;
		let isLastCharUpper = false;
		let isLastLastCharUpper = false;

		for (let i = 0; i < string.length; i++) {
			const character = string[i];

			if (isLastCharLower && UPPERCASE.test(character)) {
				string = string.slice(0, i) + '-' + string.slice(i);
				isLastCharLower = false;
				isLastLastCharUpper = isLastCharUpper;
				isLastCharUpper = true;
				i++;
			} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
				string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
				isLastLastCharUpper = isLastCharUpper;
				isLastCharUpper = false;
				isLastCharLower = true;
			} else {
				isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
				isLastLastCharUpper = isLastCharUpper;
				isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
			}
		}

		return string;
	};

	const preserveConsecutiveUppercase = (input, toLowerCase) => {
		LEADING_CAPITAL.lastIndex = 0;

		return input.replace(LEADING_CAPITAL, m1 => toLowerCase(m1));
	};

	const postProcess = (input, toUpperCase) => {
		SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
		NUMBERS_AND_IDENTIFIER.lastIndex = 0;

		return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier))
			.replace(NUMBERS_AND_IDENTIFIER, m => toUpperCase(m));
	};

	const camelCase = (input, options) => {
		if (!(typeof input === 'string' || Array.isArray(input))) {
			throw new TypeError('Expected the input to be `string | string[]`');
		}

		options = {
			pascalCase: false,
			preserveConsecutiveUppercase: false,
			...options
		};

		if (Array.isArray(input)) {
			input = input.map(x => x.trim())
				.filter(x => x.length)
				.join('-');
		} else {
			input = input.trim();
		}

		if (input.length === 0) {
			return '';
		}

		const toLowerCase = options.locale === false ?
			string => string.toLowerCase() :
			string => string.toLocaleLowerCase(options.locale);
		const toUpperCase = options.locale === false ?
			string => string.toUpperCase() :
			string => string.toLocaleUpperCase(options.locale);

		if (input.length === 1) {
			return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
		}

		const hasUpperCase = input !== toLowerCase(input);

		if (hasUpperCase) {
			input = preserveCamelCase(input, toLowerCase, toUpperCase);
		}

		input = input.replace(LEADING_SEPARATORS, '');

		if (options.preserveConsecutiveUppercase) {
			input = preserveConsecutiveUppercase(input, toLowerCase);
		} else {
			input = toLowerCase(input);
		}

		if (options.pascalCase) {
			input = toUpperCase(input.charAt(0)) + input.slice(1);
		}

		return postProcess(input, toUpperCase);
	};

	camelcase.exports = camelCase;
	// TODO: Remove this for the next major release
	camelcase.exports.default = camelCase;

	var camelcaseExports = camelcase.exports;
	var camelCase$1 = /*@__PURE__*/getDefaultExportFromCjs(camelcaseExports);

	function flattenCamelCase(source, property, target = {}) {
	  if (source == null) {
	    return target;
	  }
	  if (typeof source === "object") {
	    Object.keys(source).forEach((sourceKey) => {
	      const newSource = source[sourceKey];
	      const prefix = property != null ? camelCase$1(property + "." + sourceKey) : camelCase$1(sourceKey);
	      return flattenCamelCase(newSource, prefix, target);
	    });
	  } else if (property != null) {
	    target[property] = source;
	  }
	  return target;
	}

	var __defProp$4 = Object.defineProperty;
	var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
	var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
	var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$4 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$4.call(b, prop))
	      __defNormalProp$4(a, prop, b[prop]);
	  if (__getOwnPropSymbols$4)
	    for (var prop of __getOwnPropSymbols$4(b)) {
	      if (__propIsEnum$4.call(b, prop))
	        __defNormalProp$4(a, prop, b[prop]);
	    }
	  return a;
	};
	function getLineItemFields(lineItem) {
	  requireOptions(lineItem, "catalogObjectType", "catalogObjectId", "quantity");
	  return __spreadValues$4({
	    catalogObjectType: lineItem.catalogObjectType,
	    catalogObjectId: lineItem.catalogObjectId,
	    price: lineItem.price,
	    quantity: lineItem.quantity,
	    currency: lineItem.currency
	  }, flattenCamelCase(lineItem.attributes, "attribute"));
	}

	var __defProp$3 = Object.defineProperty;
	var __defProps$3 = Object.defineProperties;
	var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
	var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
	var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$3 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$3.call(b, prop))
	      __defNormalProp$3(a, prop, b[prop]);
	  if (__getOwnPropSymbols$3)
	    for (var prop of __getOwnPropSymbols$3(b)) {
	      if (__propIsEnum$3.call(b, prop))
	        __defNormalProp$3(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
	function extractCartEvents(actionEvent, cartInteraction, options) {
	  const cartEvent = extractCartEvent(actionEvent, options);
	  return [
	    cartEvent,
	    ...extractCartItemEvents(cartEvent, cartInteraction)
	  ];
	}
	function extractCartEvent(actionEvent, options) {
	  return __spreadProps$3(__spreadValues$3(__spreadValues$3({}, getGeneratedEventFields(actionEvent, options)), getInteractionFields(actionEvent)), {
	    category: CDPEventCategory.Engagement,
	    eventType: CDPEventType.Cart
	  });
	}
	function extractCartItemEvents(parent, cartInteraction) {
	  const cartItemEvents = [];
	  if (isAddToCartInteraction(cartInteraction) || isRemoveFromCartInteraction(cartInteraction)) {
	    requireOptions(cartInteraction, "lineItem");
	    const cartItemEvent = extractCartItemEvent(parent, cartInteraction.lineItem);
	    if (cartItemEvent != null) {
	      cartItemEvents.push(cartItemEvent);
	    }
	  } else if (isReplaceCartInteraction(cartInteraction)) {
	    requireOptions(cartInteraction, "lineItems");
	    cartInteraction.lineItems.forEach((lineItem) => {
	      const cartItemEvent = extractCartItemEvent(parent, lineItem);
	      if (cartItemEvent != null) {
	        cartItemEvents.push(cartItemEvent);
	      }
	    });
	  } else {
	    new Set(cartInteraction.lineItems).add(cartInteraction.lineItem).forEach((lineItem) => {
	      if (isLineItem(lineItem)) {
	        const cartItemEvent = extractCartItemEvent(parent, lineItem);
	        if (cartItemEvent != null) {
	          cartItemEvents.push(cartItemEvent);
	        }
	      }
	    });
	  }
	  return cartItemEvents;
	}
	function extractCartItemEvent(parent, lineItem) {
	  try {
	    return __spreadProps$3(__spreadValues$3(__spreadValues$3({}, copyParentFieldsForCDPEvent(parent)), getLineItemFields(lineItem)), {
	      [RequiredEventFields.EventType]: CDPEventType.CartItem,
	      cartEventId: parent[RequiredEventFields.EventId]
	    });
	  } catch (e) {
	    getSalesforceInteractionsInstance().log.error(e.message);
	    return null;
	  }
	}
	function isAddToCartInteraction(cartInteraction) {
	  return cartInteraction.name === CartInteractionName.AddToCart;
	}
	function isRemoveFromCartInteraction(cartInteraction) {
	  return cartInteraction.name === CartInteractionName.RemoveFromCart;
	}
	function isReplaceCartInteraction(cartInteraction) {
	  return cartInteraction.name === CartInteractionName.ReplaceCart;
	}

	var __defProp$2 = Object.defineProperty;
	var __defProps$2 = Object.defineProperties;
	var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
	var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
	var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$2 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$2.call(b, prop))
	      __defNormalProp$2(a, prop, b[prop]);
	  if (__getOwnPropSymbols$2)
	    for (var prop of __getOwnPropSymbols$2(b)) {
	      if (__propIsEnum$2.call(b, prop))
	        __defNormalProp$2(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
	function extractCatalogEvents(actionEvent, catalogObjectInteraction, options) {
	  requireOptions(catalogObjectInteraction, "catalogObject");
	  const catalogObject = catalogObjectInteraction.catalogObject;
	  return [extractCatalogEvent(actionEvent, catalogObject, options)];
	}
	function extractCatalogEvent(actionEvent, catalogObject, options) {
	  requireOptions(catalogObject, "id", "type");
	  return __spreadProps$2(__spreadValues$2(__spreadValues$2(__spreadValues$2(__spreadValues$2({}, getGeneratedEventFields(actionEvent, options)), getInteractionFields(actionEvent)), flattenCamelCase(catalogObject.attributes, "attribute")), flattenCamelCase(catalogObject.relatedCatalogObjects, "relatedCatalogObject")), {
	    category: CDPEventCategory.Engagement,
	    eventType: CDPEventType.Catalog,
	    id: catalogObject.id,
	    type: catalogObject.type
	  });
	}

	var __defProp$1 = Object.defineProperty;
	var __defProps$1 = Object.defineProperties;
	var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
	var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
	var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
	var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues$1 = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp$1.call(b, prop))
	      __defNormalProp$1(a, prop, b[prop]);
	  if (__getOwnPropSymbols$1)
	    for (var prop of __getOwnPropSymbols$1(b)) {
	      if (__propIsEnum$1.call(b, prop))
	        __defNormalProp$1(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
	function extractOrderEvents(actionEvent, orderInteraction, options) {
	  requireOptions(orderInteraction, "order");
	  const order = orderInteraction.order;
	  const orderEvent = extractOrderEvent(actionEvent, order, options);
	  return [
	    orderEvent,
	    ...extractOrderItemEvents(orderEvent, order)
	  ];
	}
	function extractOrderEvent(actionEvent, order, options) {
	  requireOptions(order, "id");
	  return __spreadProps$1(__spreadValues$1(__spreadValues$1(__spreadValues$1({}, getGeneratedEventFields(actionEvent, options)), getInteractionFields(actionEvent)), flattenCamelCase(order.attributes, "attribute")), {
	    category: CDPEventCategory.Engagement,
	    eventType: CDPEventType.Order,
	    orderId: order.id,
	    orderCurrency: order.currency,
	    orderTotalValue: order.totalValue
	  });
	}
	function extractOrderItemEvents(orderEvent, order) {
	  if (order.lineItems == null) {
	    return [];
	  }
	  const orderItemEvents = [];
	  order.lineItems.forEach((lineItem) => {
	    const orderItemEvent = extractOrderItemEvent(orderEvent, lineItem);
	    if (orderItemEvent != null) {
	      orderItemEvents.push(orderItemEvent);
	    }
	  });
	  return orderItemEvents;
	}
	function extractOrderItemEvent(orderEvent, lineItem) {
	  try {
	    return __spreadProps$1(__spreadValues$1(__spreadValues$1({}, copyParentFieldsForCDPEvent(orderEvent)), getLineItemFields(lineItem)), {
	      [RequiredEventFields.EventType]: CDPEventType.OrderItem,
	      orderEventId: orderEvent[RequiredEventFields.EventId]
	    });
	  } catch (e) {
	    getSalesforceInteractionsInstance().log.error(e.message);
	    return null;
	  }
	}

	var __defProp = Object.defineProperty;
	var __defProps = Object.defineProperties;
	var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
	var __getOwnPropSymbols = Object.getOwnPropertySymbols;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __propIsEnum = Object.prototype.propertyIsEnumerable;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __spreadValues = (a, b) => {
	  for (var prop in b || (b = {}))
	    if (__hasOwnProp.call(b, prop))
	      __defNormalProp(a, prop, b[prop]);
	  if (__getOwnPropSymbols)
	    for (var prop of __getOwnPropSymbols(b)) {
	      if (__propIsEnum.call(b, prop))
	        __defNormalProp(a, prop, b[prop]);
	    }
	  return a;
	};
	var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
	function extractCustomEvents(actionEvent, interaction, options) {
	  return [
	    ...extractCustomStructuredEvents(actionEvent, interaction, options),
	    ...extractCustomEvent(actionEvent, interaction, options)
	  ];
	}
	function extractCustomEvent(actionEvent, interaction, options) {
	  var _a;
	  const eventType = validateEventType((_a = interaction.eventType) != null ? _a : interaction.name);
	  if (eventType == null) {
	    return [];
	  }
	  const customFields = Object.keys(actionEvent.interaction).reduce((acc, key) => {
	    if (key !== "name") {
	      acc[key] = interaction[key];
	    }
	    return acc;
	  }, {});
	  return [__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, flattenCamelCase(customFields)), getGeneratedEventFields(actionEvent, options)), getInteractionFields(actionEvent)), {
	    [RequiredEventFields.EventType]: eventType,
	    [RequiredEventFields.Category]: CDPEventCategory.Engagement
	  })];
	}
	function extractCustomStructuredEvents(actionEvent, interaction, options) {
	  if ((interaction == null ? void 0 : interaction.eventType) == null) {
	    return [
	      ...extractCustomOrderEvents(actionEvent, interaction, options),
	      ...extractCustomCatalogEvents(actionEvent, interaction, options),
	      ...extractCustomCartEvents(actionEvent, interaction, options)
	    ];
	  }
	  return [];
	}
	function extractCustomOrderEvents(actionEvent, interaction, options) {
	  return hasCustomOrderInteraction(interaction) ? extractOrderEvents(actionEvent, interaction, options) : [];
	}
	function extractCustomCatalogEvents(actionEvent, interaction, options) {
	  return hasCustomCatalogObjectInteraction(interaction) ? extractCatalogEvents(actionEvent, interaction, options) : [];
	}
	function extractCustomCartEvents(actionEvent, interaction, options) {
	  return hasCustomCartInteraction(interaction) ? extractCartEvents(actionEvent, interaction, options) : [];
	}
	function hasCustomOrderInteraction(interaction) {
	  return isOrder(interaction == null ? void 0 : interaction.order);
	}
	function hasCustomCatalogObjectInteraction(interaction) {
	  return isCatalogObject(interaction == null ? void 0 : interaction.catalogObject);
	}
	function hasCustomCartInteraction(interaction) {
	  var _a;
	  return isLineItem(interaction == null ? void 0 : interaction.lineItem) || ((_a = interaction == null ? void 0 : interaction.lineItems) == null ? void 0 : _a.some(isLineItem));
	}

	function extractEngagementEvents(actionEvent, options) {
	  const interaction = actionEvent == null ? void 0 : actionEvent.interaction;
	  if (interaction == null) {
	    return [];
	  }
	  requireOptions(actionEvent.interaction, "name");
	  if (isOrderInteraction(interaction)) {
	    return extractOrderEvents(actionEvent, interaction, options);
	  } else if (isCatalogObjectInteraction(interaction)) {
	    return extractCatalogEvents(actionEvent, interaction, options);
	  } else if (isCartInteraction(interaction)) {
	    return extractCartEvents(actionEvent, interaction, options);
	  }
	  return extractCustomEvents(actionEvent, interaction, options);
	}
	function isOrderInteraction(interaction) {
	  return OrderInteractionName.Return === interaction.name || OrderInteractionName.Ship === interaction.name || OrderInteractionName.Preorder === interaction.name || OrderInteractionName.Cancel === interaction.name || OrderInteractionName.Exchange === interaction.name || OrderInteractionName.Purchase === interaction.name || OrderInteractionName.Deliver === interaction.name;
	}
	function isCatalogObjectInteraction(interaction) {
	  return CatalogObjectInteractionName.ViewCatalogObject === interaction.name || CatalogObjectInteractionName.CommentCatalogObject === interaction.name || CatalogObjectInteractionName.FavoriteCatalogObject === interaction.name || CatalogObjectInteractionName.ReviewCatalogObject === interaction.name || CatalogObjectInteractionName.ShareCatalogObject === interaction.name || CatalogObjectInteractionName.QuickViewCatalogObject === interaction.name || CatalogObjectInteractionName.ViewCatalogObjectDetail === interaction.name;
	}
	function isCartInteraction(interaction) {
	  return CartInteractionName.ReplaceCart === interaction.name || CartInteractionName.AddToCart === interaction.name || CartInteractionName.RemoveFromCart === interaction.name;
	}

	function actionEventToCDPEvents(actionEvent, options) {
	  return [
	    ...extractConsentEvents(actionEvent, options),
	    ...extractProfileEvents(actionEvent, options),
	    ...extractEngagementEvents(actionEvent, options)
	  ];
	}

	var __async$1 = (__this, __arguments, generator) => {
	  return new Promise((resolve, reject) => {
	    var fulfilled = (value) => {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    };
	    var rejected = (value) => {
	      try {
	        step(generator.throw(value));
	      } catch (e) {
	        reject(e);
	      }
	    };
	    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
	    step((generator = generator.apply(__this, __arguments)).next());
	  });
	};
	function createClient(options) {
	  const authenticator = createAuthenticator(options);
	  return (actionEvent) => __async$1(this, null, function* () {
	    const isAuthenticated = yield authenticator();
	    if (isAuthenticated) {
	      const events = actionEventToCDPEvents(actionEvent, options);
	      yield sendEvents(options, events);
	    }
	  });
	}

	var __async = (__this, __arguments, generator) => {
	  return new Promise((resolve, reject) => {
	    var fulfilled = (value) => {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    };
	    var rejected = (value) => {
	      try {
	        step(generator.throw(value));
	      } catch (e) {
	        reject(e);
	      }
	    };
	    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
	    step((generator = generator.apply(__this, __arguments)).next());
	  });
	};
	const { OnEventSend, OnException } = CustomEvents;
	function createPlugin(options) {
	  requireOptions(options, "tenantSpecificEndpoint", "authenticator");
	  requireOptions(options.authenticator, "appSourceId");
	  options.tenantSpecificEndpoint = validateTenantEndpoint(options.tenantSpecificEndpoint, "tenantSpecificEndpoint is invalid");
	  const send = createClient(options);
	  subscribe(OnEventSend, (event) => __async(this, null, function* () {
	    try {
	      if (consentOptInExists() || eventContainsOptOut(event)) {
	        yield send(event.detail.actionEvent);
	      } else {
	        getSalesforceInteractionsInstance().log.debug("event not sent to CDP because consent was not given");
	      }
	    } catch (error) {
	      getSalesforceInteractionsInstance().log.error(error.message);
	      dispatch(OnException, { error });
	    }
	  }));
	}
	function subscribe(eventName, eventHandler) {
	  function onPageHide() {
	    document.removeEventListener(eventName, eventHandler);
	    window.removeEventListener("pagehide", onPageHide);
	  }
	  document.addEventListener(eventName, eventHandler);
	  window.addEventListener("pagehide", onPageHide);
	}
	function consentOptInExists() {
	  const consents = getSalesforceInteractionsInstance().getConsents();
	  return consents.findIndex((consentWithMetadata) => consentWithMetadata.consent.status === ConsentStatus.OptIn) >= 0;
	}
	function eventContainsOptOut(event) {
	  return event.detail.actionEvent.interaction.name === MetadataUpdateInteractionName.MetadataUpdate && event.detail.actionEvent.consents.findIndex((consents) => consents.status === ConsentStatus.OptOut) >= 0;
	}

	var _a, _b;
	// Initialize the base Salesforce Interactions WebSDK module
	init({
	    consents: [
	        {
	            provider: 'ExampleProvider',
	            purpose: 'Tracking',
	            status: ConsentStatus.OptIn,
	        },
	    ],
	});
	// Initialize the CDP Event Receiver module
	createPlugin({
	    tenantSpecificEndpoint: (_a = window.dataCloudConfig) === null || _a === void 0 ? void 0 : _a.tenantSpecificEndpoint,
	    authenticator: {
	        appSourceId: (_b = window.dataCloudConfig) === null || _b === void 0 ? void 0 : _b.appSourceId,
	    },
	});

	/**
	 * Copyright (c) 2023, salesforce.com, inc.
	 * All rights reserved.
	 * SPDX-License-Identifier: MIT
	 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
	 */
	class DataLayerEventsSubscriber {
	    next(events) {
	        experienceInteractionEventHandler(events);
	    }
	    error(error) {
	        Logger.warn(`Received error from dataLayer events queue ${error.message}`);
	    }
	}
	// dataLayerEvents is a queue which listens to experience_interaction events and
	// click events(buttons and anchor tags) and inform its subscribers when an
	// event arrives. It also stores all the events until a subscriber is registered.
	// Subscribe to dataLayerEvents.
	window.dataLayerEvents.subscribe(new DataLayerEventsSubscriber());
	// Emit all the events already stored in dataLayerEvents queue.
	// As webSDK script is loaded async, it would not receive all the events which were raised before
	// the script is loaded. Hence, instruct dataLayerEvents to emit all of them.
	window.dataLayerEvents.emitEvents();

})();
